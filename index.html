<!DOCTYPE html>

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />

	<title>Mintrobi</title>

	<link rel="manifest" href="./manifest.json" />
	<meta name="description" content="Mintrobi" />
	<meta name="theme-color" content="#2F3BA2" />

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black" />
	<meta name="apple-mobile-web-app-title" content="Mintrobi" />
	<link rel="apple-touch-icon" href="./images/icons/icon-152x152.png" />

	<link rel="icon" type="image/png" href="./favicon.png" />
	<!--<link rel="stylesheet" href="./global.css" />-->

	<!-- You can remove this is you don't want to make your PWA installable 
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@pwabuilder/pwainstall"
    ></script>
-->


	<!--
Copyright (c) 2022 by Kilian Singer (https://quantumtechnology.info)

please contact if you need other license.

This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Dieses Programm ist Freie Software: Sie können es unter den Bedingungen
    der GNU General Public License, wie von der Free Software Foundation,
    Version 3 der Lizenz, weiter verteilen und/oder modifizieren.

    Dieses Programm wird in der Hoffnung bereitgestellt, dass es nützlich sein wird, jedoch
    OHNE JEDE GEWÄHR,; sogar ohne die implizite
    Gewähr der MARKTFÄHIGKEIT oder EIGNUNG FÜR EINEN BESTIMMTEN ZWECK.
    Siehe die GNU General Public License für weitere Einzelheiten.

    Sie sollten eine Kopie der GNU General Public License zusammen mit diesem
    Programm erhalten haben. Wenn nicht, siehe <https://www.gnu.org/licenses/>.

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
   IN THE SOFTWARE.
-->

	<!--https://stackoverflow.com/questions/38557822/debugging-in-visual-studio-code-with-babel-node-->
	<!--
To enable type checking for all JavaScript files without changing any code, just add "javascript.implicitProjectConfig.checkJs": true to your workspace or user settings. This enables type checking for any JavaScript file that is not part of a jsconfig.json or tsconfig.json project.
You can opt individual files out of type checking with a // @ts-nocheck comment at the top of the file:
TODO: implement doors as rooms that repeat the last go... command
you can make a door also an orc that blocks the road
-->

	<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=utf-8">
	<meta http-equiv="Cache-control" content="no-cache">
	<meta http-equiv="Cache-control" content="no-store">
	<style>
		a:link {
			color: cyan;
			background-color: transparent;
			text-decoration: none;
		}

		a:visited {
			color: rgb(0, 181, 181);
			background-color: transparent;
			text-decoration: none;
		}

		a:hover {
			color: red;
			background-color: transparent;
			text-decoration: underline;
		}

		a:active {
			color: yellow;
			background-color: transparent;
			text-decoration: underline;
		}

		html {
			color: #ffaa55;
			background-color: #000000;
			margin: 10px;
			font-family: Arial, Helvetica, Sans-Serif;
			font-size: 18pt;
		}

		#story {
			position: absolute;
			top: 10px;
			bottom: 80px;
			left: 10px;
			right: 10px;
			overflow: auto;

		}

		#story p {
			margin: 0.2em 0;
			white-space: pre-wrap;
			overflow: auto;

		}

		#inputline {
			position: absolute;
			bottom: 0pt;
			left: 18pt;
			right: 18pt;
		}

		#story .command {
			color: #00FF00;
			font-style: italic;
			margin-top: 0.2em;
		}

		.command::before {
			color: #00FF00;
			content: "\25B6";
			margin-right: 0.5em;
			font-style: normal;
		}

		#prompt {
			background: #000000;
			color: #00FF00;
		}
		#compass{
			background: #000000;
			color: #00FF00;
		
		}
		#lookbackpack{
			font-size: 15pt;
		
		}

		#inp {
			width: 80%;
			background: #222222;
			color: #00FF00;
			height: 1.5em;
			font-family: Arial, Helvetica, Sans-Serif;
			font-size: 18pt;
		}

		.flow {
			position: relative;
			top: 0;
			left: 0;
			width: 80%;
		}

		.back {
			position: relative;
			top: 0;
			left: 0;
			width: 100%;
		}

		#s1oma1 {
			position: absolute;
			top: 39.81%;
			left: 43.12%;
			width: 11.4%;
			animation: fade 10s;
			animation-iteration-count: infinite;
		}

		#s1oma2 {
			position: absolute;
			top: 39.81%;
			left: 43.12%;
			width: 11.4%;
			animation: invfade 10s;
			animation-iteration-count: infinite;
		}

		#s2opa1 {
			position: absolute;
			left: 82.13%;
			top: 42.6%;
			width: 14.06%;
			animation: fade 10s;
			animation-iteration-count: infinite;
		}

		#s2opa2 {
			position: absolute;
			left: 82.13%;
			top: 42.6%;
			width: 14.06%;
			animation: invfade 10s;
			animation-iteration-count: infinite;
		}

		#s2krabbe1 {
			position: absolute;
			left: 64.0%;
			top: 80.5%;
			width: 6.35%;
			animation: fade 30s;
			animation-iteration-count: infinite;
		}

		#s2krabbe2 {
			position: absolute;
			left: 64.0%;
			top: 80.5%;
			width: 6.35%;
			animation: invfade 30s;
			animation-iteration-count: infinite;
		}

		#s2tuer1 {
			position: absolute;
			left: 40.104%;
			top: 41.57%;
			width: 7.44%;
			animation: fade 20s;
			animation-iteration-count: infinite;
		}

		#s2tuer2 {
			position: absolute;
			left: 40.104%;
			top: 41.57%;
			width: 7.44%;
			animation: invfade 20s;
			animation-iteration-count: infinite;
		}

		#s2vase {
			position: absolute;
			left: 37.55%;
			top: 49.91%;
			width: 4.48%;
		}

		#s3frau1 {
			position: absolute;
			left: 10%;
			top: 21.48%;
			width: 18.64%;
			animation: fade 30s;
			animation-iteration-count: infinite;
		}

		#s3frau2 {
			position: absolute;
			left: 10%;
			top: 21.48%;
			width: 18.64%;
			animation: invfade 30s;
			animation-iteration-count: infinite;
		}

		#s3kind1 {
			position: absolute;
			left: 49.07%;
			top: 52.22%;
			width: 10%;
			animation: fade 20s;
			animation-iteration-count: infinite;
		}

		#s3kind2 {
			position: absolute;
			left: 48.07%;
			top: 52.22%;
			width: 10%;
			animation: invfade 20s;
			animation-iteration-count: infinite;
		}

		#s3junge1 {
			position: absolute;
			left: 75%;
			top: 39.16%;
			width: 14.90%;
			animation: fade 2s;
			animation-iteration-count: infinite;
		}

		#s3junge2 {
			position: absolute;
			left: 75%;
			top: 39.16%;
			width: 14.90%;
			animation: invfade 2s;
			animation-iteration-count: infinite;
		}

		#s4barkeeper1 {
			position: absolute;
			left: 9.11%;
			top: 16.20%;
			width: 14.32%;
			animation: fade 2s;
			animation-iteration-count: infinite;
		}

		#s4barkeeper2 {
			position: absolute;
			left: 9.11%;
			top: 16.20%;
			width: 14.32%;
			animation: invfade 2s;
			animation-iteration-count: infinite;
		}

		#s4tortentyp1 {
			position: absolute;
			left: 47.40%;
			top: 22.31%;
			width: 17.08%;
			animation: fade 10s;
			animation-iteration-count: infinite;
		}

		#s4tortentyp2 {
			position: absolute;
			left: 47.40%;
			top: 22.31%;
			width: 17.08%;
			animation: invfade 10s;
			animation-iteration-count: infinite;
		}

		#s4bar {
			position: absolute;
			left: 0%;
			top: 48.3%;
			width: 28.9%;
		}

		#s4seetang {
			position: absolute;
			left: 86.66%;
			top: 12.12%;
			width: 9.11%;
		}

		#s5artist1 {
			position: absolute;
			left: 23.38%;
			top: 41.48%;
			width: 14.06%;
			animation: fade 10s;
			animation-iteration-count: infinite;
		}

		#s5artist2 {
			position: absolute;
			left: 23.38%;
			top: 41.48%;
			width: 14.06%;
			animation: invfade 10s;
			animation-iteration-count: infinite;
		}

		#s5seller1 {
			position: absolute;
			left: 12.91%;
			top: 30.37%;
			width: 5.36%;
			animation: fade 20s;
			animation-iteration-count: infinite;
		}

		#s5seller2 {
			position: absolute;
			left: 12.91%;
			top: 30.37%;
			width: 5.36%;
			animation: invfade 20s;
			animation-iteration-count: infinite;
		}

		#s5tante1 {
			position: absolute;
			left: 77.23%;
			top: 31.48%;
			width: 7.5%;
			animation: fade 30s;
			animation-iteration-count: infinite;
		}

		#s5tante2 {
			position: absolute;
			left: 77.23%;
			top: 31.48%;
			width: 7.5%;
			animation: invfade 30s;
			animation-iteration-count: infinite;
		}

		#s7forscher1 {
			position: absolute;
			left: 41.51%;
			top: 18.51%;
			width: 9.11%;
			animation: fade 30s;
			animation-iteration-count: infinite;
		}

		#s7forscher2 {
			position: absolute;
			left: 41.51%;
			top: 18.51%;
			width: 9.37%;
			animation: invfade 30s;
			animation-iteration-count: infinite;
		}

		#s8wache1 {
			position: absolute;
			left: 18.43%;
			top: 4.62%;
			width: 9.37%;
			animation: fade 5;
			animation-iteration-count: infinite;
		}

		#s8wache2 {
			position: absolute;
			left: 18.43%;
			top: 4.62%;
			width: 9.11%;
			animation: invfade 5s;
			animation-iteration-count: infinite;
		}

		#s8torauf {
			position: absolute;
			left: 21.91%;
			top: 29.44%;
			width: 28.64%;
		}

		#s8torzu {
			position: absolute;
			left: 21.91%;
			top: 29.44%;
			width: 28.64%;
		}

		#s8schild {
			position: absolute;
			left: 16.56%;
			top: 19.16%;
			width: 10.26%;
		}

		#s9pina1 {
			position: absolute;
			left: 28.08%;
			top: 57.4%;
			width: 3.03%;
			animation: fade 5;
			animation-iteration-count: infinite;
		}

		#s9pina2 {
			position: absolute;
			left: 28.08%;
			top: 57.4%;
			width: 3.03%;
			animation: invfade 5s;
			animation-iteration-count: infinite;
		}

		#s9mojito1 {
			position: absolute;
			left: 13.12%;
			top: 61.66%;
			width: 6.35%;
			animation: fade 3s;
			animation-iteration-count: infinite;
		}

		#s9mojito2 {
			position: absolute;
			left: 13.12%;
			top: 61.66%;
			width: 6.35%;
			animation: invfade 3s;
			animation-iteration-count: infinite;
		}

		#s9daiquiri1 {
			position: absolute;
			left: 70.52%;
			top: 69.6%;
			width: 8.33%;
			animation: fade 1s;
			animation-iteration-count: infinite;
		}

		#s9daiquiri2 {
			position: absolute;
			left: 70.52%;
			top: 69.6%;
			width: 8.33%;
			animation: invfade 1s;
			animation-iteration-count: infinite;
		}

		#s9daiquiri3 {
			position: absolute;
			left: 70.52%;
			top: 69.6%;
			width: 8.33%;
			visibility: hidden;
		}

		#s9mauer {
			position: absolute;
			left: 11.25%;
			top: 60.74%;
			width: 3.43%;
		}

		img {
			height: auto;
			display: block;
		}

		@keyframes fade {
			0% {
				opacity: 0
			}

			9% {
				opacity: 0
			}

			10% {
				opacity: 1
			}

			20% {
				opacity: 1
			}

			21% {
				opacity: 0
			}

			29% {
				opacity: 0
			}

			30% {
				opacity: 1
			}

			39% {
				opacity: 1
			}

			40% {
				opacity: 1
			}

			50% {
				opacity: 1
			}

			51% {
				opacity: 0
			}

			59% {
				opacity: 0
			}

			60% {
				opacity: 0
			}

			69% {
				opacity: 0
			}

			70% {
				opacity: 1
			}

			80% {
				opacity: 1
			}

			81% {
				opacity: 0
			}

			89% {
				opacity: 0
			}

			90% {
				opacity: 1
			}

			99% {
				opacity: 1
			}

			100% {
				opacity: 0
			}
		}

		@keyframes invfade {
			0% {
				opacity: 1
			}

			10% {
				opacity: 1
			}

			11% {
				opacity: 0
			}

			19% {
				opacity: 0
			}

			20% {
				opacity: 1
			}

			30% {
				opacity: 1
			}

			31% {
				opacity: 0
			}

			39% {
				opacity: 0
			}

			40% {
				opacity: 0
			}

			49% {
				opacity: 0
			}

			50% {
				opacity: 1
			}

			59% {
				opacity: 1
			}

			60% {
				opacity: 1
			}

			70% {
				opacity: 1
			}

			71% {
				opacity: 0
			}

			79% {
				opacity: 0
			}

			80% {
				opacity: 1
			}

			90% {
				opacity: 1
			}

			91% {
				opacity: 0
			}

			98% {
				opacity: 0
			}

			99% {
				opacity: 1
			}
		}
		.flexed { 
  			display: flex; 
		}
		.flexele{
			align-self: center;
		}
		.hflexed{
			display: flex; 
			flex-direction: column;
		}
	</style>
</head>

<body>
	<noscript>
		<div>Oops! Javascript required here! Allow it and try again!</div>
	</noscript>

	<script>
		if ("serviceWorker" in navigator) {
			window.addEventListener("load", () => {
				navigator.serviceWorker.register("./service-worker.js").then((reg) => {
					console.log("Service worker registered.", reg);
				});
			});
		}
	</script>
</body>


<body onload="start()">
	<div id="story"></div>
	<div id="inputline" class="flexed">
		<span  id="lookbackpack" class="hflexed">
			<span class="flexele"><a id="look"  onclick='exec(T`${DE}B${EN}L`.toString(),true);' href='javascript:void(0);'>&#128269;</a></span>
			<span class="flexele"><a>&nbsp;</a></span>
			<span class="flexele"><a id="backpack"  onclick='exec(T`${DE}R${EN}B`.toString(),true);' href='javascript:void(0);'>&#128092;</a></span>
		</span>
		<span id="compass" class="hflexed">
			<span class="flexele"><a id="north"  onclick='exec(this,true);' href='javascript:void(0);'>N</a></span>
			<span class="flexele"><a id="west"  onclick='exec(this,true);' href='javascript:void(0);'>W</a>+<a id="east"  onclick='exec(this,true);' href='javascript:void(0);'>O</a></span>
			<span class="flexele"><a id="south"  onclick='exec(this,true);' href='javascript:void(0);'>S</a></span>
		</span>
		<span id="prompt" class="flexele">
			&#x25B6;
		</span>
		<input id="inp" class="flexele">
	</div>
</body>
<!-- Load Babel copied from https://unpkg.com/@babel/standalone/babel.min.js forwared to https://unpkg.com/@babel/standalone@7.11.3/babel.min.js-->
<script>
// @ts-check
</script>
<script>
	// https://lancaster-university.github.io/microbit-docs/resources/bluetooth/bluetooth_profile.html
	// An implementation of Nordic Semicondutor's UART/Serial Port Emulation over Bluetooth low energy
	const UART_SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
	// Allows the micro:bit to transmit a byte array
	const UART_TX_CHARACTERISTIC_UUID = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";
	// Allows a connected client to send a byte array
	const UART_RX_CHARACTERISTIC_UUID = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";
	let uBitDevice;
	let rxCharacteristic;
	async function microBitWriteBluetooth(string) {
		var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
		if (!isChrome) {
			print(T`<em style='color:#faa;'>${DE}Du musst einen modernen Chrome/Edge Browser verwenden damit das geht!${EN}You have to use a modern Chrome/Edge browser for this to work!${ALL}</em>\n`)
			return;
		}
		if (!rxCharacteristic) {
			return;
		}
		try {
			let encoder = new TextEncoder();
			rxCharacteristic.writeValue(encoder.encode(string));
		} catch (error) {
			console.log(error);
		}
	}
	let bluetooth = false;
	async function microBitConnect(name) {
		var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
		if (!isChrome) {
			print(T`<em style='color:#faa;'>${DE}Du musst einen modernen Chrome/Edge Browser verwenden damit das geht!${EN}You have to use a modern Chrome/Edge browser for this to work!${ALL}</em>\n`)
			return false;
		}
		if (bluetooth) return true;
		try {
			console.log("Requesting Bluetooth Device...");
			//TODO use navigator.bluetooth.getDevices similar to usb uart
			uBitDevice = await navigator.bluetooth.requestDevice({
				filters: [{ namePrefix: "BBC micro:bit" + (name == "" ? "" : " [" + name + "]") }],
				optionalServices: [UART_SERVICE_UUID]
			});

			console.log("Connecting to GATT Server...");
			const server = await uBitDevice.gatt.connect();

			console.log("Getting Service...");
			const service = await server.getPrimaryService(UART_SERVICE_UUID);

			console.log("Getting Characteristics...");
			const txCharacteristic = await service.getCharacteristic(
				UART_TX_CHARACTERISTIC_UUID
			);
			txCharacteristic.startNotifications();
			txCharacteristic.addEventListener(
				"characteristicvaluechanged",
				onTxCharacteristicValueChanged
			);
			rxCharacteristic = await service.getCharacteristic(
				UART_RX_CHARACTERISTIC_UUID
			);

			uBitDevice.addEventListener('gattserverdisconnected', onDisconnected);
			bluetooth = true;
			return true;
		} catch (error) {
			bluetooth = false;
			console.log(error);
			return false;
		}
	}
	async function onDisconnected(event) {
		bluetooth = false;
		// Object event.target is Bluetooth Device getting disconnected.
		console.log('Bluetooth Device disonnected');
	}
	function microBitDisconnect() {
		if (!uBitDevice) {
			return;
		}
		if (uBitDevice.gatt.connected) {
			uBitDevice.gatt.disconnect();
			console.log("Disconnected");
		}
	}
	let microBitReceivedMessageCB;
	// A function that returns a promise to resolve into the data //fetched from the API or an error
	let microBitReadBluetooth = () => {
		return new Promise(
			(resolve, reject) => {

				microBitReceivedMessageCB = resolve;
			}
		)
	}
	function onTxCharacteristicValueChanged(event) {
		let receivedData = [];
		for (var i = 0; i < event.target.value.byteLength; i++) {
			receivedData[i] = event.target.value.getUint8(i);
		}
		const receivedString = String.fromCharCode.apply(null, receivedData);
		if (typeof microBitReceivedMessageCB !== 'undefined') {

			microBitReceivedMessageCB(receivedString);
		} else {
			console.log("microBitReceivedMessageCB is not defined")
		}
		//console.log(receivedString);
	}
	function sleep(ms) {
		return new Promise(resolve => setTimeout(resolve, ms));
	}
	///////////////////////////////////
	//usb serial
	//https://thecodebarbarian.com/async-generator-functions-in-javascript.html#:~:text=Async%20generator%20functions%20behave%20similarly,()%20function%20returns%20a%20promise.
	//https://www.javascripttutorial.net/es-next/javascript-async-generators/
	//https://stackoverflow.com/questions/71262432/how-can-i-close-a-web-serial-port-that-ive-piped-through-a-transformstream
	async function writeMicrobit(txt) {
		var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
		if (!isChrome) {
			print(T`<em style='color:#faa;'>${DE}Du musst einen modernen Chrome/Edge Browser verwenden damit das geht!${EN}You have to use a modern Chrome/Edge browser for this to work!${ALL}</em>\n`)
			return false;
		}
		if ("serial" in navigator) {
			// The Web Serial API is supported.

			// Prompt user to select any serial port.
			try {
				// Get all serial ports the user has previously granted the website access to.
				const filters = [
					{ usbVendorId: 0x0D28, usbProductId: 0x0204 },

				];
				const ports = await navigator.serial.getPorts();
				let port = null;
				console.log(JSON.stringify(filters))
				for (let i = 0; i < ports.length; ++i) {
					let info = ports[i].getInfo();
					console.log(JSON.stringify(info))
					if (info.usbProductId == filters[0].usbProductId && info.usbVendorId == filters[0].usbVendorId) port = ports[i];
				}

				if (!port) port = await navigator.serial.requestPort({ filters });
				console.log(port)
				console.log("Available\n" + JSON.stringify(port))
				await port.open({
					baudRate: 115200,
					dataBits: 8,
					stopBits: 1,
					parity: "none",
					bufferSize: 1024,
					flowControl: "none"
				});
				const textEncoder = new TextEncoderStream();
				const writer = textEncoder.writable.getWriter();
				const writableStreamClosed = textEncoder.readable.pipeTo(port.writable);
				await writer.write(txt);//\r\n
				// Allow the serial port to be closed later.
				writer.close();
				await writableStreamClosed;
				await port.close()
				return true;
			} catch (e) {
				console.log(e)
				return false;
			}

		}
	}
	async function readMicrobit() {
		var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
		if (!isChrome) {
			print(T`<em style='color:#faa;'>${DE}Du musst einen modernen Chrome/Edge Browser verwenden damit das geht!${EN}You have to use a modern Chrome/Edge browser for this to work!${ALL}</em>\n`)
			return "";
		}
		if ("serial" in navigator) {
			// The Web Serial API is supported.

			// Prompt user to select any serial port.
			let textDecoder;
			let readableStreamClosed;
			let reader;
			let port = null;
			let str = "";
			try {
				// Get all serial ports the user has previously granted the website access to.
				const filters = [
					{ usbVendorId: 0x0D28, usbProductId: 0x0204 },

				];
				const ports = await navigator.serial.getPorts();

				//console.log(JSON.stringify(filters))
				for (let i = 0; i < ports.length; ++i) {
					let info = ports[i].getInfo();
					//console.log(JSON.stringify(info))
					if (info.usbProductId == filters[0].usbProductId && info.usbVendorId == filters[0].usbVendorId) port = ports[i];
				}

				if (!port) port = await navigator.serial.requestPort({ filters });
				//console.log(port)
				//console.log("Available\n" + JSON.stringify(port))
				await port.open({
					baudRate: 115200,
					dataBits: 8,
					stopBits: 1,
					parity: "none",
					bufferSize: 1024,
					flowControl: "none"
				});

				textDecoder = new TextDecoderStream();
				readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
				reader = textDecoder.readable.getReader();

				// Listen to data coming from the serial device.
				//we might want to use timeout https://stackoverflow.com/questions/65748344/how-can-i-interrupt-a-reader-when-it-hangs-need-a-timeout-on-reader-read
				str = "";
				let firsttimeout = 10000;
				while (true) {
					const { value, done } = await Promise.race([
						reader.read(),
						new Promise((_, reject) => setTimeout(reject, firsttimeout, new Error("timeout")))
					]);
					firsttimeout = 50;
					str = str + value;
					if (done) {
						reader.releaseLock();
						break;
					}
				}
				//console.log("text:"+str);
				return str;
			} catch (e) {
				//console.log(e)

				return str;//this is the normal control flow
			}
			finally {//executed before return in try and catch
				try {
					reader.cancel();
					await readableStreamClosed.catch(() => { /* Ignore the error */ });

					await port.close();
				}
				catch (e) {

				}
			}

		}
	}
	function randint(min, max) {
		return Math.floor(Math.random() * (max - min + 1)) + min;
	}
</script>
<script src="pong.js"></script>

<script src="babel.min.js"></script>
<script>
	// Define a preset https://medium.com/jspoint/a-minimal-guide-to-ecmascript-decorators-55b70338215e
	Babel.registerPreset("env-plus", {
		presets: [
			[Babel.availablePresets["env"], {
				"loose": true,
				"targets": { "browsers": "> 0.3%, not dead" }
			}]
		],
		plugins: [
			[
				Babel.availablePlugins["proposal-decorators"], { "decoratorsBeforeExport": true }
			],
			[
				Babel.availablePlugins["proposal-class-properties"],
				{
					"loose": true
				}
			]
		],
	});
</script>
<!-- Decorator example -->
<script type="text/babel" data-presets="env-plus">
	//https://dev.to/adam_cyclones/oporator-overloading-in-javascript-292f
	//https://stackoverflow.com/questions/5222209/getter-setter-in-constructor
	//!!!!!!!!!  TODO the Translation code below needs to be derived from Obj such that serialization works


	// @ts-check
	class Obj {
		static arr = [];
		static dict = {};
		static idcnt = 0;
		id = 0;
		constructor() {
			this.id = Obj.idcnt;
			Obj.arr[this.id] = this;
			Obj.idcnt++;
		}
		name = undefined;
		static nametag() {
			// search through the global object for a name that resolves to this object

			for (var name in window) {
				if (window[name] instanceof Obj) {
					for (var i in Obj.arr) {

						if (window[name] == Obj.arr[i] && !Obj.dict.hasOwnProperty(name)) {
							Obj.arr[i].name = name;
							Obj.dict[name] = Obj.arr[i];
						}
					}
				}
			}
		}


		static inspect(object, num = 0) {
			switch (typeof (object)) {

				case "undefined":
					return "undefined";
				case "string":
					return "\"" + object.replace(/\n/g, "\\n").replace(/\"/g, "\\\"") + "\"";
				case "object":
					if (object == null) {
						return "null";
					}
					if (num > 0 && object instanceof Obj) return "Obj.dict['" + object.name + "']"
					var a = [];
					if (object instanceof Array) {
						for (var i in object) {
							if (i != "raw") a.push(Obj.inspect(object[i], ++num));
						};
						return "[" + a.join(", ") + "]";
					} else {

						for (var key in object) {
							if (object.hasOwnProperty(key)) {
								if (num === 0 && (key === "id" || key === "name")) continue;
								if (typeof (object[key]) === "function") continue;//skip functions to avoid hacks
								a.push('"' + key + '"' + ": " + Obj.inspect(object[key], ++num));
							}
						};
						return "{" + a.join(", ") + "}";
					}
				default:
					return object.toString();
			}
		};
		static dump() {
			//TODO the save routine cannot currently handle non global objects. Also it cannot handle multiple global references to objects. References need to be stored in Obj classes
			//also it currently kills all non Obj types by just overwriting the object.
			//so we loose all methods
			//we should use: Object.getPrototypeOf(object1) and Object.setPrototypeOf(obj, prototype)
			Obj.nametag();
			let a = ["{"];

			//TODO use Object.create(eval('TData'))
			//so we need to store obj.constructor.name
			for (var key in Obj.dict) {
				a.push('"' + key + '":' + Obj.inspect(Obj.dict[key]) + ",");
			}
			a.push("}");
			return a.join('');
		}

		static isIterable(obj) {
			// checks for null and undefined
			if (obj == null) {
				return false;
			}
			return typeof obj[Symbol.iterator] === 'function';
		}
		static assign(source, skey, target, tkey) {//if we use objects and the key then it is passed by reference
			if (target[tkey] instanceof Obj) {
				target[tkey] = source[skey];
			}
			else {
				try {//we have object not inherited of Obj
					let proto = Object.getPrototypeOf(target[tkey])
					//let proto=.dict[key][key2].prototype;
					target[tkey] = source[skey];
					Object.setPrototypeOf(target[tkey], proto)
				} catch (e) {
					target[tkey] = source[skey];
				}
			}
		}
		static restore(data) {
			//TODO currently we do only the keys inside object and nothing of higher depth
			//this can be done by using the Obj.dict[key] and sending key2 into recursive function
			//because keys in objects are sent by ref
			let dict2;
			eval('dict2=' + data);

			for (var key in dict2) {
				if (key in Obj.dict) {
					for (var key2 in Obj.dict[key]) {
						if (Obj.dict[key].hasOwnProperty(key2))
							if (key2 in dict2[key]) {
								if (Obj.dict[key][key2] instanceof Array) {
									for (var key3 in Obj.dict[key][key2]) {
										Obj.assign(dict2[key][key2], key3, Obj.dict[key][key2], key3)
									}
								}

								Obj.assign(dict2[key], key2, Obj.dict[key], key2)

								//try{	//TODO use Object.create(eval('TData'))
								//https://stackoverflow.com/questions/12690107/clone-object-without-reference-javascript


							}
					}
				}
			}
		}
	}

	/*
						if(typeof(dict2[key])=="object"){
							
							if(dict[key] instanceof Obj){
								dict[key]=dict2[key]
							}else{
								dict[key] = Object.create(eval(dict2[key]["____TYPE____"]))
								let proto=Object.getPrototypeOf(dict[key])
								dict[key]=dict2[key]
								Object.setPrototypeOf(dict[key], proto)
							}
							delete dict[key]["____TYPE____"]
						}
						else dict[key]=dict2[key];
						*/
	/*
				for (var key in dict2) {
					if (key in Obj.dict) {
						for (var key2 in Obj.dict[key]) {
							if (Obj.dict[key].hasOwnProperty(key2))
								if (key2 in dict2[key]) {
									if(isIterable(dict2[key][key2])) restore(dict2[key][key2])
									
									//TODO use Object.create(eval('TData'))
									//let proto=Object.getPrototypeOf(Obj.dict[key][key2])
	
									//we need to do iterative here
									if(typeof(dict2[key][key2])=="object" && dict2[key][key2] && dict2[key][key2]["____TYPE____"]) {
										console.log("creating: "+dict2[key][key2]["____TYPE____"])
								
										Obj.dict[key][key2] = Object.create(eval(dict2[key][key2]["____TYPE____"]))
										let proto=Object.getPrototypeOf(Obj.dict[key][key2])
										Obj.dict[key][key2]=dict2[key][key2];
										delete Obj.dict[key][key2]["____TYPE____"]
										Object.setPrototypeOf(Obj.dict[key][key2], proto)
									} else {
										Obj.dict[key][key2] = dict2[key][key2];
									}
								
									
								}
						}
					}
				}
				*/


	let DE = "DE_asdfjkhwaqluifehwjlajkawe";//unique reference to empty object
	let EN = "EN_asdfjkhwaqluifehwjlajkawe";
	let ALL = "ALL_asdfjkhwaqluifehwjlajkawe";
	let LANGUAGES = [DE, EN, ALL]


	class MODEObj extends Obj {
		constructor(lang, pro) {
			super();
			this.lang = lang;
			this.pro = pro;
		}
	}

	const params = new Proxy(new URLSearchParams(window.location.search), {
		get: (searchParams, prop) => searchParams.get(prop),
	});
	//http://127.0.0.1:5500/index.html?lang=EN&pro=1
	let MODE = new MODEObj(params.lang == "EN" ? EN : DE, params.pro == "1")


	function isNumeric(str) {
		if (typeof str != "string") return false // we only process strings!  
		return !isNaN(str) && // use type coercion to parse the _entirety_ of the string (`parseFloat` alone does not do this)...
			!isNaN(parseFloat(str)) // ...and ensure strings of whitespace fail
	}
	//Multilanguage interface:
	//let aa=T`${DE}abc${EN}DE${10*2}F${DE}gh${2+2}i`;//${DE} marks german region
	//interface is compatible with normal strings. but you need to do s.toString() or s+"" to start conversion

	class TData extends Object {
		_value = null
		constructor(...args) {
			super();
			this._value = args[0]
			try { delete this._value[0].raw; } catch (e) { }
			JSON.stringify(args[0]);
		}
		/*	[Symbol.for('+')](other) {//https://www.delftstack.com/howto/javascript/javascript-operator-overloading/
				console.log("!!!!!!!!!!!!!")
			   let n=new TData("");
				n._value=this._value
				n._value[0].concat(other._value[0])
				n._value.concat(other._value.slice(1))
				return n;
			}
			*/
		toString() {
			let s = "";
			let active = true;
			this._value[0].forEach((el, i) => {
				let lastact = active
				if (active) s += el;
				let normalval = ""
				if (this._value[i + 1] == MODE.lang || this._value[i + 1] == ALL) active = true;
				else if (i < this._value.length - 1 && LANGUAGES.includes(this._value[i + 1])) active = false;
				else {
					if (i < this._value.length - 1) {
						console.log(i)
						//${["link"]} : is link that calls exec(this)
						//${["link",""]}  calls typeCommand(this)
						//${["text","link"]} : is link that calls exec(link) and displays text
						//${["text","link",""]} : is link that calls typeCommand(link) and displays text
						//${["text","",""]} : clears inputfield
						
						if ( this._value[i + 1] instanceof Array) {
							if(this._value[i + 1].length==1) normalval = "<a onclick='exec(this);' href='javascript:void(0);'>" + this._value[i + 1][0].toString() + "</a>";
							else if(this._value[i + 1].length==2 && this._value[i + 1][1]=="") normalval = "<a onclick='typeCommand(this);' href='javascript:void(0);'>" + this._value[i + 1][0].toString() + "</a>";
							else if(this._value[i + 1].length==2 && this._value[i + 1][1]!="") normalval = "<a onclick='exec(\""+this._value[i + 1][1].toString()+"\");' href='javascript:void(0);'>" + this._value[i + 1][0].toString() + "</a>";
							else if(this._value[i + 1].length==3 &&  this._value[i + 1][1]!="" && this._value[i + 1][2]=="") normalval = "<a onclick='typeCommand(\""+this._value[i + 1][1].toString()+"\");' href='javascript:void(0);'>" + this._value[i + 1][0].toString() + "</a>";
							else if(this._value[i + 1].length==3 &&  this._value[i + 1][1]=="" && this._value[i + 1][2]=="") normalval = "<a onclick='clearCommand();' href='javascript:void(0);'>" + this._value[i + 1][0].toString() + "</a>";
						}
						else normalval = this._value[i + 1].toString()
					}

				}
				if (lastact) s += normalval;
			})
			//console.log(_value.map(x=>x===DE))
			return s
		}
		valueOf() {
			return this.toString()
		}
	}
	function T(...args) {
		return new TData(args);
	}

	document.getElementById("east").innerText=T`${DE}O${EN}E`.toString();
	
	class Thing extends Obj {
		/** @member {string} */
		_title = [""];
		get title () {
    		return this._title;
  		};
  		set title (value) {
			if (!(value instanceof Array)) {
				console.log("not arr")
				this._title = [value];

			}
			else this._title=value;	
  		};
		description = "";
		speakable = false;//when true you can speak with it. you need to add: XXX.dialog=async function* ()
		opensoninspection = false;//is closed but when you look at it by command "look at item" it opens.
		takeable = false;//when true you can take it. you need to add take function take
		dropable = false;//when true you can drop it. do not add any function
		//function 'receiving' is called after take is called such that object is in posession of other person
		//but if you return false the object is given back

		//'giving' is called when you take something from a person
		//if you return false it is rejected 
		//'receiving' and giving are called in 'take' function
		//you do not write functions take and drop
		usable = false;//when true you can use it. you need to add function use
		openable = false;//when true you can give things, that is drop things there do not add any function
		applicable = false;//when true you cann apply it. add function doApply
		closable = false;//when true you can close it,do not add any function
		open = false;
		blocking = false;//used if a person blocks a direction or a door blocks a direction;
		blockable = false;//if true we can block and unblock.used if a person blocks a direction or a door can block a direction must be set true when we insert something that blocks;
		locked = false;//use this only for doors not for boxes.

		visible = false;
		things = {};//items,scenes,persons
		applytarget = {};
		parent = null;
		position = null;
		take(thing, force = false) {
			let retval = true;
			if (!force && thing.parent.giving) retval = thing.parent.giving(thing);
			if (retval) {
				let old = thing.parent;
				thing.parent.remove(thing)
				this.insert(thing);
				if (this.receiving && !force) retval &= this.receiving(thing);//here we have recursive problem with calling take in receiving but only when calling take directly
				if (!retval) {
					thing.parent.remove(thing)
					old.insert(thing);
				}
				return retval;
			}
			else return false;
		}
		constructor(title, description) {
			//let title2
			//if (!(title instanceof Array)) title2 = [title];
			//else title2 = title;
			super();
			this.title = title;
			this.description = description;
		}
		printcommands() {
			let ret = "";
			if (this !== Commands.actor && (this.speakable || this.takeable || this.dropable || this.usable || this.openable || this.applicable || this.closable)) {
				let cnt = 0;
				ret += T`</br>${DE}Befehle: ${EN}Commands: `.toString();
				if (this.speakable) {
					ret += T`${[T`${DE}sprich mit ${EN}speak with `+this.title[0].toString()]}`;
					cnt++;
				}
				if (this.takeable && !Commands.actor.has(this)) {
					ret += (cnt > 0 ? ", " : "") + T`${[T`${DE}nimm ${EN}take `+this.title[0].toString()]}`;
					cnt++;
				}
				if (this.dropable && Commands.actor.has(this)) {
					ret += (cnt > 0 ? ", " : "") + T`${[T`${DE}lege ${EN}drop `+this.title[0].toString()]}`;
					cnt++;
					ret += (cnt > 0 ? ", " : "") + T`${[T`${DE}gib ${EN}give `+this.title[0].toString()+ T`${DE} an${EN} to`.toString(),""]}`;
					cnt++;
				}
				if (this.usable) {
					ret += (cnt > 0 ? ", " : "") + T`${[T`${DE}verwende ${EN}use `+this.title[0].toString()]}`;
					cnt++;
				}
				if (this.openable && !this.open) {
					ret += (cnt > 0 ? ", " : "") + T`${[T`${DE}öffne ${EN}open `+this.title[0].toString()]}`
					cnt++;
				}
				if (this.applicable) {
					ret += (cnt > 0 ? ", " : "") + T`${[T`${DE}verwende ${EN}use `+this.title[0].toString()+ T`${DE} mit${EN} with`.toString(),""]}`;
					cnt++;
				}
				if (this.closable && this.open) {
					ret += (cnt > 0 ? ", " : "") + T`${[T`${DE}schließe ${EN}close `+this.title[0].toString()]}`
					cnt++;
				}


			}
			return ret;
		}
		describe() {
			if (this.opensoninspection) this.open = true;
			let ret = T`${[this.title[0].toString()]}`.toString()+": " + this.description.toString();
			ret += this.printcommands()
			return ret;
		}
		insert(thing) {
			if (thing.name === undefined) Obj.nametag()
			this.things[thing.name] = thing;
			thing.parent = this;
		}
		remove(thing) {
			if (thing.name === undefined) Obj.nametag()
			if (this.things.hasOwnProperty(thing.name)) {
				delete this.things[thing.name];
				return true;
			}
			return false;
		}
		has(thing) {
			if (thing.name === undefined) Obj.nametag()
			return this.things.hasOwnProperty(thing.name)
		}
		insertApplyTarget(target) {
			if (target.name === undefined) Obj.nametag()
			this.applytarget[target.name] = target;
		}
		removeApplyTarget(target) {
			if (target.name === undefined) Obj.nametag()
			if (this.applytarget.hasOwnProperty(target.name)) delete this.applytarget[target.name];
		}

		async speak(choice = "") {
			if (!this.dialog) return "";
			if (!this.iter) this.iter = this.dialog();
			let result = await this.iter.next(choice);
			if (result.done) this.iter = this.dialog();
			return result;
		}

	}
	class Scene extends Thing {//is not takeable
		constructor(title, description, { openable = false, opensoninspection = false, closable = false, open = true, visible = true } = {}) {
			super(title, description);
			this.openable = openable;
			this.open = open;
			this.closable = closable;
			this.opensoninspection = opensoninspection;
		}
		northblock = undefined;
		northdir = undefined;
		set north(target) {
			this.northdir = target;
			if (!target.south) target.south = this;
		}
		get north() {
			return this.northdir;
		}
		southblock = undefined;
		southdir = undefined;
		set south(target) {
			this.southdir = target;
			if (!target.north) target.north = this;
		}
		get south() {
			return this.southdir;
		}
		eastblock = undefined;
		eastdir = undefined;
		set east(target) {
			this.eastdir = target;
			if (!target.west) target.west = this;
		}
		get east() {
			return this.eastdir;
		}
		westblock = undefined;
		westdir = undefined;
		set west(target) {
			this.westdir = target;
			if (!target.east) target.east = this;
		}
		get west() {
			return this.westdir;
		}
		upblock = undefined;
		updir = undefined;
		set up(target) {
			this.updir = target;
			if (!target.down) target.down = this;
		}
		get up() {
			return this.updir;
		}
		downblock = undefined;
		downdir = undefined;
		set down(target) {
			this.downdir = target;
			if (!target.up) target.up = this;
		}
		get down() {
			return this.downdir;
		}
	}
	class Door extends Thing {
		constructor(title, description, { openable = false, opensoninspection = false, closable = false, open = false, visible = true, takeable = false, dropable = false, usable = false, applicable = false, blockable = true, blocking = true, locked = false, speakable = false } = {}) {
			super(title, description);
			this.speakable = speakable;
			this.openable = openable;
			this.closable = closable;
			this.open = open;
			this.visible = visible;
			this.takeable = takeable;
			this.dropable = dropable;
			this.usable = usable;
			this.opensoninspection = opensoninspection;
			this.applicable = applicable;
			this.blockable = blockable;
			this.blocking = blocking;
			this.locked = locked;
		}
	}
	/**
	 * Class representing an item.
	 * @extends Thing
	 */
	class Item extends Thing {//is takeable
		constructor(title, description, { openable = false, opensoninspection = false, closable = false, open = false, visible = true, takeable = true, dropable = true, usable = false, applicable = false } = {}) {
			super(title, description);
			this.openable = openable;
			this.closable = closable;
			this.open = open;
			this.visible = visible;
			this.takeable = takeable;
			this.dropable = dropable;
			this.usable = usable;
			this.opensoninspection = opensoninspection;
			this.applicable = applicable;
		}
	}
	class Person extends Thing {
		position = null;
		constructor(title, description, { speakable = true, opensoninspection = false, openable = false, closable = false, open = false, visible = true, takeable = false, dropable = false, usable = false } = {}) {
			super(title, description);
			this.speakable = speakable;
			this.openable = openable;
			this.closable = closable;
			this.open = open;
			this.visible = visible;
			this.takeable = takeable;
			this.dropable = dropable;
			this.opensoninspection = opensoninspection;
			this.usable = usable;
		}
	}
	class BlockingPerson extends Thing {
		position = null;
		constructor(title, description, { speakable = true, opensoninspection = false, openable = false, closable = false, open = false, visible = true, takeable = false, dropable = false, usable = false, blockable = true, blocking = true, locked = false } = {}) {
			super(title, description);
			this.speakable = speakable;
			this.openable = openable;
			this.closable = closable;
			this.open = open;
			this.visible = visible;
			this.takeable = takeable;
			this.dropable = dropable;
			this.opensoninspection = opensoninspection;
			this.usable = usable;
			this.blockable = blockable;
			this.blocking = blocking;
			this.locked = locked;
		}
	}
	/*
	replaceWords works as follows
		param={thing:""}
		ret=replaceWords("look => THING","look at bottle message",param) 
		ret:	'look => bottle message'
		param: {thing: 'bottle message'}
	*/
	function replaceWords(command, inputcommand, param) {
		let upper = false;
		let words = command.split(' ');
		let words2 = inputcommand.split(' ');
		let command2 = command;
		let arrowindex = 0;
		for (arrowindex in words2) if (words2[arrowindex] === "=>") break;
		let correction = 0;
		for (var ii in words) {
			let i = Number(ii);//carefull: javascript takes indices to arrays as string!!!
			if (words[i].toUpperCase() == words[i] && words[i] !== "=>") {
				upper = true;
				let key = words[i].toLowerCase();
				if (words2[i + correction]) {
					if (i == words.length - 1) words[i] = words2.slice(i + correction).join(" ");
					else if ((i < words.length - 1) && words[i + 1] === "=>") {
						words[i] = words2.slice(i + correction, Number(arrowindex) + correction).join(" ");
						correction = Number(arrowindex) - 1 - Number(i);
					}
					else words[i] = words2[i + correction];
				}
				if (words[i].includes("=>")) return "";
				param[key] = words[i];
			}
		}
		if (upper) {
			command2 = words.join(" ");
			//console.log(command2,command,inputcommand);
			//console.log(JSON.stringify(param));
		}
		return command2;
	}
	//https://isamatov.com/javascript-decorators-tutorial/
	function when(command, param = {}) {
		if (command == "") return false;//here important to use == because then with TData a toValue is done. with === it would be always false, this is needed if we specify only one language and not the other alternatives
		return function (target) {
			const original = target.descriptor.value;
			if (typeof original === 'function') {
				target.descriptor.value = function (...args) {
					let command2 = replaceWords(command.toString(), Commands.command, param);//Commands.command is the input
					if (!original.toString().startsWith("function ()") && args[0]) {
						return original.apply(this, args);//we have direct call
					}
					//console.log(`Arguments: ${args}`);
					try {
						if (Commands.command === command2) Commands.recogparam = param;
						if (!original.toString().startsWith("function ()") && Commands.recogparam === null) return false;//no command match
						else if (original.toString().startsWith("function ()")) return original.apply(this, args);//handing through parameters for direct call
						else return original.apply(this, [Commands.recogparam]);//handling match
					} catch (e) {
						throw e;
					}
				}
			}
			return target;
		}
	}
	function isEmpty(obj) {
		for (var key in obj) {
			if (obj.hasOwnProperty(key))
				return false;
		}
		return true;
	}
	function lookrecursive(things, at, found = false, key = null, list = false, quiet = false, cnt = 1) {
		let thing = null;
		for (var i in things) {
			var foundhere = false;
			for (let j in things[i].title) {
				if (things[i].title[j] && things[i].title[j].toString().toLowerCase() === at) {
					thing = things[i]; found = true; foundhere = true;
				}
			}
			if (found && !quiet && (key === null || things[i] instanceof key)) {
				if (list) print("\n" + Array(cnt).join('   ') + "&#x26AC; "+T`${[things[i].title[0].toString()]}`.toString() );
				else print("\n" + Array(cnt).join('   ') + "&#x26AC; " + things[i].describe().toString() + "\n" + Array(cnt).join('   '));
			}
			if (things[i].open && !isEmpty(things[i]["things"])) {
				if (found) if (!quiet && (key === null || things[i] instanceof key)) print(T` ${DE}mit:${EN}with:`);
				if (found) list = true;
				let foundthere = lookrecursive(things[i]["things"], at, found, key, list, quiet, cnt + 1);

				if (!foundhere && foundthere) return foundthere;
			}
			if (foundhere) return thing;
		}
		return null;
	}
	function search(thingname, typ = null) {
		let mine = true;
		let thing = lookrecursive(Commands.actor.things, thingname, false, typ, false, true);
		if (thing === null && Commands.actor.position.open) {
			mine = false;
			thing = lookrecursive(Commands.actor.position.things, thingname, false, typ, false, true);
		}
		return { mine: mine, thing: thing };
	}
	var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
	///////////////////////////////////////////////////////
	let ich = new Person("Kai", T`${DE}Du bist interessiert an der Wissenschaft und willst die Welt erforschen.${EN}You are interested in science and want to explore the world.${DE} </br>Du kannst immer <em style='color:#0f0;'>${["hilfe"]}</em> eingeben, wenn du nicht weiter kommst. </br>${EN} </br>You can always enter <em style='color:#0f0;'>${["help"]}</em> when you are stuck. </br>`
		, { open: true });
	ich.title = "Kai"
	ich.age = 8;
	var Pong = null;
	let computer = new Person(T`${DE}Computer${EN}Computer`, T`${DE}Computer mit Pong spiel.${EN}Computer with Pong game.`, { usable: true });
	var pongcanv = null;
	computer.use = function () {
		Commands.forward_command = T`${DE}t computer${EN}t computer`.toString();
		return false;
	}
	computer.dialog = async function* () {
		if (MODE.pro) return T`${DE}Für dieses Spiel musst du einen Mintrobi haben. Du hast jedoch den C++ Programmierkurs gewählt. Weshalb dieses Rätsel übersprungen wird.${EN}For this game you must have a Mintrobi. However, you have chosen the C++ programming course. Therefore, this puzzle is skipped.`;
		yield (!isChrome ? T`<em style='color:#faa;'>${DE}Achtung damit alles funktioniert solltest du das Spiel mit einem modernen Chrome/Edge Browser starten! ${EN}Attention: For everything to work, you should start the game with a modern Chrome/Edge browser!${ALL}</em> </br>` : "") +
			T`${DE}Baue eine Steuerung des Spiels. Hier ist der Code:${EN}Build a control of the game. Here is the code: ${ALL}<a target='_blank' href='https://makecode.microbit.org/#pub:_XUx3dT0fdM2P'>Code</a>. </br>${DE}Dann musst Du das Programm auf das Gehirn von Mintrobi hochgeladen. </br>${EN}Then you have to upload the programme to Mintrobi's brain. </br>${DE}Falls Du in Makecode verbunden bist, musst du die Verbindung nach dem Hochladen des Programms erst noch trennen. </br>${EN}If you are connected in Makecode, you must first disconnect after uploading the programme. </br>${ALL}<img width='20%' src='unpair.gif'>${DE}Drücke [ENTER] wenn du soweit bist.${EN}Press [ENTER] when you are ready.`
		yield T`${DE}Jetzt musst du nur noch wie folgt verkabeln:<img width='50%' src='poti.png'> </br>Drücke [ENTER] wenn du soweit bist.${EN}Now you just have to wire it as follows:<img width='50%' src='poti.png'> </br>Press [ENTER] when you are ready.`;
		while (true) {
			if (pongcanv != null) pongcanv.remove();
			pongcanv = document.createElement('canvas');
			story.appendChild(pongcanv);
			story.scrollTop = story.scrollHeight - story.clientHeight
			Pong = Object.assign({}, Game);
			Pong.initialize();
			let nochmal = yield T`${DE}Nochmal${EN}Again${ALL}? <p style='color:#0f0;'>${["1"]} - ${DE}Ja.${EN}Yes.${ALL}  </br>${["2"]} - ${DE}Nein.${EN}No.${ALL}</p>`
			if (nochmal != "1") return "Ok.";
		}
	}
	let omazuhause = new Scene(T`${DE}Omas Haus${EN}Grandma's house`, T`<div class='flow'><img class='back' src='s1.png'><img id='s1oma1' src='s1oma1.png'><img id='s1oma2' src='s1oma2.png'></div>${DE}Du bist im Haus deiner Grosseltern. </br>${EN}You are at your grandmother's house. </br>${DE}Deine Oma steht im Wohnzimmer. </br>${EN}Your granny is standing in the living room. </br>${DE}Der Ausgang zum Strand ist ${["westlich"]} von dir. </br>${EN}The exit to the beach is to the ${["west"]} of you. </br>${DE}Das Spiel wurde unterstützt durch ${EN}The game was supported by ${ALL}<a target='_blank' href='https://www.startnext.com/pages/unikat/campaign/smart-city-kassel-344#/'>Smart City Kassel</a> </br>${DE}und dem ${EN}and the ${ALL}<a target='_blank' href='https://www.uni-kassel.de/forschung/sfb/sfb-1319-elch/'>SFB-ELCH (Uni-Kassel)</a>.`);
	let oma = new Person([T`${DE}Oma${EN}Granny`, T`${DE}Großmutter${EN}Grandmother`, T`${DE}Omi`], T`${DE}Deine liebe Oma.${EN}Your dear Grandmother.`);
	omazuhause.insert(oma);
	omazuhause.insert(computer);
	ich.position = omazuhause;
	oma.dialog = async function* () {
		while (true) {
			let reply = yield (!isChrome && !MODE.pro ? T`<em style='color:#faa;'>${DE}Achtung: Damit alles funktioniert solltest du das Spiel mit einem modernen Chrome/Edge Browser starten! ${EN} </br>Attention: For everything to work, you should start the game with a modern Chrome/Edge browser! ${DE}Falls du <em style='color:#0f0;'>4</em> wählst ist der Browser egal!</em> </br>${EN}In case you choose <em style='color:#0f0;'>4</em>, then the choice of browser is irrelevant!</em> </br>` : "") + ich.title +
				T`${DE}, du bist ja endlich mal aufgewacht! Ich weiss gar nicht ob wir dir Dein Geburtstagsgeschenk den Mintrobi schon bestellt und zusammengebaut haben. ${EN}, you have finally woken up! I don't even know if we have already ordered and assembled your birthday present, the Mintrobi. ${ALL}<p style='color:#0f0;'>${DE}${["1"]} - Ja, wir haben schon alles bestellt und zusammengebaut. </br>${EN}${["1"]} - Yes, we have already ordered and assembled everything. </br>${DE}${["2"]} - Ich muss ihn noch zusammenbauen! </br>${EN}${["2"]} - I still have to assemble it! </br>${DE}${["3"]} - Wir müssen ihn noch bestellen! </br>${EN}${["3"]} - We still need to order it! </br>${DE}${["4"]} - Mintrobi? Pipifax, ich will C++ Programmierprofi werden ohne diesen Kinderkram! </br>${EN}${["4"]} - Mintrobi? Piece of cake, I want to become a C++ programming expert without this kid stuff! </br>${DE}${["5"]} - Du verwechselst mich ich bin jemand anderes! </br>${EN}${["5"]} - You've mistaken me for someone else! </br>${DE}${["6"]} - Ich würde gerne eine Wissenssendung im Fernsehen anschauen! </br>${EN}${["6"]} - I would love to watch a science programme on TV! </br>${DE}${["7"]} - Ich geh mal spazieren!${EN}${["7"]} - I'll go for a walk!${ALL}</p>`
			switch (reply) {
				case "1":
					MODE.pro = false;
					let reply2 = "";
					while (reply2 != 7) {
						let p = 2;
						reply2 = yield (reply2 == "" ? T`${DE}Das Gehirn von dem Mintrobi ist der kleine farbige Chip. Den müssen wir erst noch programmieren. Hier ein paar Übungen: ${EN}The brain of the Mintrobi is the little coloured chip. We still have to programme it. Here are a few exercises: ${ALL}<p style='color:#0f0;'>` : T`${DE}Übung macht den Meister${EN}Practice makes perfect${ALL}: <p style='color:#0f0;'>`) +
							T`${["1"]} - <a target='_blank' href='https://makecode.microbit.org/#pub:_VyuiWdV2LhE8'>${DE}Mache einen Smiley${EN}Make a smiley${ALL}</a> </br>${["2"]} - <a target='_blank' href='https://makecode.microbit.org/#pub:_C90eVc79ADWv'>${DE}Mache kleinen Film${EN}Make a small movie${ALL}</a> </br>${["3"]} - <a target='_blank' href='https://makecode.microbit.org/#pub:_HufEVJRw52vP'>${DE}Mache Geräusche${EN}Make noise${ALL}</a> </br>${["4"]} - <a target='_blank' href='https://makecode.microbit.org/#pub:_itjWEp51qUU7'>${DE}Mache ein Feuerknopf hinzu${EN}Add a fire button${ALL}</a> </br>${["5"]} - <a target='_blank' href='https://makecode.microbit.org/#pub:_8muMDLDucUxu'>${DE}Spiele die Tonleiter${EN}Play the scale${ALL}</a> </br>${["6"]} - <a target='_blank' href='https://makecode.microbit.org/#pub:_gma3HXbP56wz'>${DE}Zeige deinen Namen${EN}Show your name${ALL}</a> </br>${["7"]} - <a target='_blank' href='https://makecode.microbit.org/#pub:_2YsaPx2FrPdt'>${DE}Mache einen Zahlenwürfel${EN}Make a number dice${ALL}</a> </br>${["8"]} - <a target='_blank' href='https://makecode.microbit.org/#pub:_4XRfVyFpzbV6'>${DE}Mache einen Würfel mit Augen${EN}Make a dice with spots${ALL}</a> </br>${["9"]} - ${DE}Ich will keine Übungen mehr machen sondern mal was richtiges Spielen.${EN}I don't want to do any more exercises, I want to play something real for a change.${ALL}</p>`
						switch (reply2) {
							case "1": window.open("https://makecode.microbit.org/#pub:_VyuiWdV2LhE8", "_blank")?.focus();
								break;
							case "2": window.open("https://makecode.microbit.org/#pub:_C90eVc79ADWv", "_blank")?.focus();
								break;
							case "3": window.open("https://makecode.microbit.org/#pub:_HufEVJRw52vP", "_blank")?.focus();
								break;
							case "4": window.open("https://makecode.microbit.org/#pub:_itjWEp51qUU7", "_blank")?.focus();
								break;
							case "5": window.open("https://makecode.microbit.org/#pub:_8muMDLDucUxu", "_blank")?.focus();
								break;
							case "6": window.open("https://makecode.microbit.org/#pub:_gma3HXbP56wz", "_blank")?.focus();
								break;
							case "7": window.open("https://makecode.microbit.org/#pub:_2YsaPx2FrPdt", "_blank")?.focus();
								break;
							case "8": window.open("https://makecode.microbit.org/#pub:_4XRfVyFpzbV6", "_blank")?.focus();
								break;
							case "9":
								return T`${DE}Ah dann kannst Du ja mal versuchen den Computer zu reparieren. Ich würde gerne mal wieder Computer spielen. Was war noch? Ah, Opa hat nach dir gefragt. Er hat etwas mysteriöses gefunden, das er dir gerne zeigen möchte.${EN}Ah, then you can try to repair the computer. I'd like to play computer games again. What else? Ah, grandpa was asking about you. He found something mysterious that he wants to show you.`;
							default:
								Commands.understood = false;
								continue;
						}
					}
					break;
				case "2":
					MODE.pro = false;
					return T`${DE}Opa hat hier ein Video hochgeladen, das du gerne auf unserem Fernseher schauen kannst${EN}Grandpa has uploaded a video here that you are welcome to watch on our TV${ALL}: <a target='_blank' href='https://www.youtube.com/embed/8m-lXWjnjYI?autoplay=1'>${DE}Aufbauvideo${EN}Assembly video${ALL}</a>. </br>${DE}Und wenn du fertig bist, dann geh doch nach drausen zu Opa. Er hat etwas mysteriöses gefunden, das er dir gerne zeigen möchte.${EN}And when you're done, why don't you go outside and see grandpa? He has found something mysterious that he would like to show you.`;
				case "3":
					MODE.pro = false;
					return T`${DE}Dann helfe mir doch schnell dabei. Hier ist der Bestelllink${EN}Then help me with it quickly. Here is the order link${ALL}: <a target='_blank' href='https://www.reichelt.de/my/1978474'>Mintrobi</a>. ${DE}Wir reden dann wieder, wenn die Lieferung da ist.${EN}We'll talk again when the shipment arrives.`;
				case "4":
					MODE.pro = true;
					return T`${DE}Kein Problem! Dann kannst Du alle Bastelaufgaben überspringen statt dessen C++ Programme erstellen. Wenn Du noch keine Ahnung hast oder im Spiel nicht mehr weiter weist, dann kannst Du hier Videos schauen: ${EN}No problem! Then you can skip all the tinkering tasks and create C++ programmes instead. If you still have no idea or are stuck in the game, you can watch videos here: ${ALL}<a target='_blank' href='https://www.youtube.com/watch?v=E53dZ8mW6tQ&list=PLEWVM-KBUSpmWSfyoFdD_hLWAY_9tTgi5&index=1'>${DE}Abenteuer Programmieren auf Youtube${EN}Adventure Programming on Youtube${ALL}</a>.`
				case "5":
					let name = yield T`${DE}Oh entschuldigung, wie heißt du nochmal?${EN}Oh sorry, what is your name again?`
					name = name.charAt(0).toUpperCase() + name.slice(1)
					ich.title = [name];
					let age
					while (true) {
						age = yield T`${DE}Und wie alt bist Du nochmal?${EN}And how old are you again?`
						if (!isNaN(+age)) break;
					}
					ich.age = age;
					continue;
				case "6":
					window.open("https://www.youtube.com/embed/1IoC9r9c-so?autoplay=1", "_blank")?.focus();
					return T`${DE}Viel Spaß bei dem Film <a target='_blank' href='https://www.youtube.com/embed/1IoC9r9c-so?autoplay=1'>Einen eigenen Elektromagneten einfach selber bauen</a>${EN}Enjoy the film <a target='_blank' href='https://www.youtube.com/embed/1IoC9r9c-so?autoplay=1'>Easy to build your own electromagnet</a>`
				case "7":
					return T`${DE}Tschüss${EN}Bye!`;
				default:
					Commands.understood = false;
					continue;
			}
		}
	}
	let strand = new Scene(T`${DE}Strand${EN}Beach`, T`<div class='flow'><img class='back' src='s2.png'><img id='s2opa1' src='s2opa1.png'><img id='s2opa2' src='s2opa2.png'><img id='s2krabbe1' src='s2krabbe1.png'><img id='s2krabbe2' src='s2krabbe2.png'><img id='s2tuer1' src='s2tuer1.png'><img id='s2tuer2' src='s2tuer2.png'><img id='s2vase' src='s2vase.png'></div>${DE}Du stehst am Strand vorm Haus deiner Grosseltern, </br>an dem sich ein kleiner Steg befindet. </br>${EN}You are standing on the beach in front of your grandparents' house, </br>where there is a small walkway. </br>${DE}Dort sitzt dein Opa und angelt. </br>Nach ${["Osten"]} geht es in das Haus deiner Grosseltern, im ${["Westen"]} geht der Strand weiter. </br>${EN}That's where your grandfather sits and fishes. </br>To the ${["east"]}, you can go to your grandparents' house, </br>to the ${["west"]}, the beach continues.`)
	strand.east = omazuhause;
	let bottlemessage = new Item(T`${DE}Flaschenpost${EN}bottle message`, T`<img src='bottlemessage.png'>${DE}eine verschlossene Flaschenpost${EN}a sealed message in a bottle`);
	let opa = new Person([T`${DE}Opa${EN}Grandpa`, T`${DE}Großvater${EN}Grandfather`], T`${DE}Dein lieber Opa.${EN}Your dear grandpa.`);
	strand.insert(opa);
	opa.insert(bottlemessage);
	opa.dialog = async function* () {
		if (this.has(bottlemessage)) {
			while (true) {
				let reply = yield T`${DE}Hallo ${EN}Hello ` + ich.title + T`${DE} hast du gut geschlafen? Naja ist nicht so wichtig, ich habe eine komische Nachricht aus dem Meer gefischt. Hier guck mal.${EN} did you sleep well? Well, it's not that important, I fished a funny message out of the sea. Here, take a look.${ALL} <p style='color:#0f0;'>${DE}${["1"]} - Och nee, dafür bin ich jetzt noch viel zu müde. </br>${EN}${["1"]} - Oh no, I'm much too tired for that now. </br>${DE}${["2"]} - Echt???! Zeig mal her was du gefunden hast.${EN}${["2"]} - Really???! Let me see what you found.${ALL}</p>`
				switch (reply) {
					case "1":
						return T`${DE}Ach Schade. Dann komm doch später nochmal zu mir.${EN}Oh, that's too bad. Then come back to me later.`
					case "2":
						this.open = true;
						Commands.actor.take(bottlemessage);
						this.open = false;
						return T`${DE}Hier eine geheimnisvolle Flasche ich mache sie gleich in deinen Rucksack${EN}Here's a mystery bottle I'll put in your backpack right away${ALL} (<em style='color:#0f0;'>${DE}schaue in rucksack${EN}look in backpack${ALL}</em>, <em style='color:#0f0;'>${DE}betrachte flaschenpost${EN}look at bottle message${ALL}</em>), </br>${DE}aber ich bekomme sie leider einfach nicht auf. </br>${EN}but unfortunately I just can't get it open. </br>${DE}Du brauchst einen Flaschenöffner, vielleicht findest du ja einen. </br>${EN}You'll need a bottle opener, maybe you can find one. </br>` + bottlemessage.describe()
					default:
						Commands.understood = false;
						continue;
				}
			}
		} else {
			return T`${DE}Fischen ist lustig.${EN}Fishing is fun.`;
		}
	}
	opa.receiving = function (thing) {
		print(T`${DE}Nein behalte das. Das ist fuer dich. </br>${EN}No keep that. That is for you. </br>`);
		return false;
	}
	let scene3 = new Scene(T`${DE}Badestrand${EN}Beach`, T`<div class='flow'><img class='back' src='s3.png'><img id='s3frau1' src='s3frau1.png'><img id='s3frau2' src='s3frau2.png'><img id='s3kind1' src='s3kind1.png'><img id='s3kind2' src='s3kind2.png'><img id='s3junge1' src='s3junge1.png'><img id='s3junge2' src='s3junge2.png'></div>${DE}Du stehst am Strand, um dich herum sind einige Leute. </br>Nach ${["Norden"]} geht es in die Stadt, </br>nach ${["Osten"]} zum Strandhaus, </br>im ${["Westen"]} ist eine Strandbar.${EN}You are standing on the beach, there are some people around you. </br>To the ${["north"]} it goes to the city, </br>to the ${["east"]} to the beach house, </br>to the ${["west"]} is a beach bar.`)

	let loch = new Item(T`${DE}Loch${EN}Hole`, T`${DE}Ein tiefes Loch${EN}A deep hole.`, { open: false, opensoninspection: true, takeable: false, dropable: false });
	loch.giving = function (thing) {
		print(T`${DE}Das Loch ist zu tief!${EN}The hole is too deep!`);
		return false;
	}
	loch.receiving = function (thing) {
		print(T`${DE}Besser nicht, sonst ists weg.${EN}Better not, otherwise it's gone.`)
		return false;
	}

	let holzschluessel = new Item([T`${DE}Holzschlüssel${EN}Wooden key`, T`${DE}Holz Schlüssel${EN}Wood key`], T`${DE}Ein hölzerner Schlüssel.${EN}A wooden key.`, { applicable: true });

	loch.insert(holzschluessel);
	scene3.insert(loch);

	let eimer = new Item(T`${DE}Eimer${EN}Bucket`, T`${DE}Ein roter Eimer.${EN}A red bucket.`, { applicable: true });
	scene3.insert(eimer);

	let meer = new Item(T`${DE}Meer${EN}Ocean`, T`${DE}Schönes Meer.${EN}Beautiful ocean`, { takeable: false, dropable: false });
	scene3.insert(meer);
	eimer.insertApplyTarget(meer);
	eimer.insertApplyTarget(loch);

	eimer.leer = true;

	eimer.doapply = function (target) {
		//if(target===ocean) return target.doapply(this);//is needed because reciproce call only works when doapply is not there
		if (target === meer) {
			this.title = [T`${DE}Vollen Eimer${EN}Full bucket`, T`${DE}Voller Eimer${EN}Full bucket`, T`${DE}Eimer${EN}Bucket`]
			this.description = T`${DE}Ein mit Meerwasser gefüllter roter Eimer.${EN}A red bucket filled with ocean water.`
			eimer.voll = true;
			print(eimer.describe())
			return true;
		}
		else if (target === loch) {
			if (eimer.voll) {
				print(T`${DE}Oh der Holzschlüssel schwimmt auf der Wasseroberfläche. Den nehm ich mir!${EN}Oh the wooden key floats on the water surface. I'll take it.`)
				Commands.actor.take(holzschluessel, true);
				eimer.voll = false;
				eimer.title = [T`${DE}Eimer${EN}Bucket`]
				eimer.description = T`${DE}Ein roter Eimer.${EN}A red bucket.`

				return true;
			} else {
				return false;
			}
		}
		else if (target === holzstumpf) {
			if (eimer.voll) {
				print(T`${DE}Leider schwimmt der Metallschlüssel nicht.${EN}Unfortunately, the metal key does not float.`)
				return true;
			} else return false;
		}
		return false;
	}
	scene3.east = strand;
	let frau = new Person(T`${DE}Frau${EN}Woman`, T`${DE}ein Frau${EN}a woman`);
	scene3.insert(frau);
	frau.dialog = async function* () {
		return T`${DE}Endlich mal Ruhe. In der Stadt ist echt was los. </br>Diesen Urlaub habe ich mir echt verdient.${EN}Peace at last. There's really something going on in the city. </br>I've really earned this holiday.`;
	}
	let kind = new Person([T`${DE}Kind${EN}Child`, T`${DE}Mädchen${EN}Girl`], T`${DE}ein Kind${EN}a child`);
	scene3.insert(kind);
	kind.dialog = async function* () {
		return T`${DE}Da sind interessant verkleidete Menschen im Wald. </br>Hast du schonmal einen von denen gesehen?${EN}There are interesting people in disguise in the forest. </br>Have you ever seen one of them?`;
	}
	let junge = new Person([T`${DE}Junge${EN}Boy`, T`${DE}Jungen`], T`${DE}ein Junge${EN}a boy`);
	scene3.insert(junge);
	junge.dialog = async function* () {
		return T`${DE}Hey schau mal, </br>diese Sandburg habe ich ganz alleine gebaut!${EN}Hey look, </br>I built this sandcastle all by myself!`;
	}
	let scene4 = new Scene(T`${DE}Strandbar${EN}Beach-bar`, "")
	scene4.east = scene3;
	let seetang = new Door(T`${DE}Seetang${EN}Seaweed`, T`${DE}Ein Haufen riechender Seetang. Hm, yam, yam, ich liebe Sushi-Rolls!${EN}A pile of smelly seaweed. Mmm, yam, yam, I love sushi rolls!`, { blocking: true, usable: true, locked: true })
	seetang.cnt = 0;
	seetang.use = function () {
		seetang.cnt++;
		if (seetang.cnt >= 3) {
			seetang.blocking = false;
			print(scene4.describe());
			return true;
		}
		else {
			print(T`${DE}Nichts passiert. Aber ich nehme mir ein Stück zum essen. Hm, lecker!${EN}Nothing happens. But I take a piece to eat. Hm, yummy!`);
			return true;
		}
	}
	scene4.northblock = seetang;
	scene4.insert(seetang);
	scene4.describe = function () {
		seetang.cnt = 0;
		if (seetang.blocking) {
			return T`<div class='flow'><img class='back' src='s4.png'><img id='s4barkeeper1' src='s4barkeeper1.png'><img id='s4barkeeper2' src='s4barkeeper2.png'><img id='s4tortentyp1' src='s4tortentyp1.png'><img id='s4tortentyp2' src='s4tortentyp2.png'><img id='s4bar' src='s4bar.png'><img id='s4seetang' src='s4seetang.png'></div>${DE}Du stehst in einer offenen Strandbar mit einigen Leuten. </br>Nach ${["Osten"]} geht es zum Strand.${EN}You are standing in an open beach bar with a few people. </br>To the ${["east"]} you can go to the beach.` + this.printcommands();
		}
		else return T`<div class='flow'><img class='back' src='s4.png'><img id='s4barkeeper1' src='s4barkeeper1.png'><img id='s4barkeeper2' src='s4barkeeper2.png'><img id='s4tortentyp1' src='s4tortentyp1.png'><img id='s4tortentyp2' src='s4tortentyp2.png'><img id='s4bar' src='s4bar.png'></div>${DE}Oh da ist ja eine geheime Höhle dahinter im ${["Norden"]}. Was da wohl drin ist? </br>Nach ${["Osten"]} geht es zum Strand.${EN}Ooh, there's a secret cave behind there in the ${["north"]}. I wonder what's in there? </br>To the ${["east"]} you can go to the beach.` + this.printcommands();
	}
	let barmann = new Person(T`${DE}Barmann${EN}Bartender`, T`${DE}ein Barmann${EN}a bartender`);
	scene4.insert(barmann);
	barmann.tricked = false;
	barmann.receiving = function (thing) {
		if (thing === tortenheber) {
			Commands.forward_command = T`${DE}t barmann${EN}t bartender`
			return false;
		}
	}
	barmann.dialog = async function* () {
		if (Commands.actor.has(tortenheber) || barmann.tricked) {
			if (seetang.blocking) {
				let reply;
				while (true) {
					reply = yield T`${DE}Dankeschön! Dankeschön! Das ist echt mega, dass du meinen Tortenheber gefunden hast. </br>Ich dachte schon den sehe ich nie wieder. </br>Wenn du schonmal hier bist kannst du mir kurz helfen?${EN}Thanks a lot! That's really cool that you found my cake server. </br>I thought I'd never see it again. </br>While you're here can you give me a hand?${ALL} <p style='color:#0f0;'>${DE}${["1"]} - Ja na klar! Was muss ich tun? </br>${EN}${["1"]} - Of course! What do I need to do? </br>${DE}${["2"]} - Nein, ich habe gerade keine Lust.${EN}${["2"]} - No, I don't feel like it right now.${ALL}</p>`;
					switch (reply) {
						case "1":
							let reply13 = yield T`${DE}Ich habe gehört, dass du Programieren kannst und vielleicht kannst du auch mier weiter helfen. </br>Ich muss diese ${EN}I heard that you can programme and maybe you can help me too. </br>I need to get this ` + (MODE.pro ? "5" : "3") + T`${DE}-stöckige Torte auf diesen Teller bringen, </br>doch da gibt es ein Problem. </br>Ich kann jedes Stück nur alleine bewegen und es </br>darf nie ein größeres Stueck auf einem kleineren liegen. Es gibt drei Plätze A, B und C. Die Torte ist anfangs auf Platz A und muss nach B. Platz C kann man als Zwischenablage verwenden. </br>Hast du eine Idee wie ich das am besten mache? Gib die Lösung in der Form AB,CD,...  ein! Du kannst das einfach durch überlegen lösen oder ein Computerprogramm schreiben.${EN} tier cake onto this plate, but there is a problem. </br>I can only move each piece on its own and there </br>never has to be a larger piece on top of a smaller one. There are three places A, B and C. The pie is initially on place A and must go to B. Place C can be used as a clipboard. </br>Do you have any idea how I can best do this? Enter the solution in the form AB,CD,....  ! You can solve this simply by thinking or you can write a computer program.${DE} Hier der link zum ${EN} Here is the link to the ` + (MODE.pro ? `<a target='_blank' href='https://www.youtube.com/watch?v=E4wT2HM0VpY&list=PLEWVM-KBUSpmWSfyoFdD_hLWAY_9tTgi5&index=24'>Video</a>` : `<a target='_blank' href='https://makecode.microbit.org/#pub:_7DzXT3eF7iiu'>Code</a>.`);

							if (reply13 === (MODE.pro ? "ac,ab,cb,ac,ba,bc,ac,ab,cb,ca,ba,cb,ac,ab,cb,ac,ba,bc,ac,ba,cb,ca,ba,bc,ac,ab,cb,ac,ba,bc,ac" : "ab,ac,bc,ab,ca,cb,ab") || reply13 === (MODE.pro ? "ac,ab,cb,ac,ba,bc,ac,ab,cb,ca,ba,cb,ac,ab,cb,ac,ba,bc,ac,ba,cb,ca,ba,bc,ac,ab,cb,ac,ba,bc,ac," : "ab,ac,bc,ab,ca,cb,ab,")) {
								return T`${DE}Das hat geklappt. Hier ich öffne dir die Flasche. ${EN}That worked. Here, I'll open the bottle for you. ` +
									(
										MODE.pro ? T`${DE}Da ist ein verschlüsselter Text drin: ${EN}There is an encrypted text inside (the plain text is German so you need to translate it after decryption with e.g. <a target='_blank' href='https://deepl.com'>Deepl</a>): ${ALL} </br><textarea rows='8' cols='80' style='white-space: wrap;' >DFOEM-+8O/BGO/FG@+0O.=0OMBG-8+0OYB8O/->>+0OF+*+G>-QQ+0<OEB+ODF7 8+0OB'G+O -QB*+G<O='0+ODFOD=+R+G0<O/-EO>F+GO+B0O>QF7'<OB7'O'-*+ORQF+7 OE=0E8O'-8O0B+Y-0@OF+*+GQ+*8<O8G=8DO'='+GOE++O =008+OB7'OYB7'OR+G-@+O0=7'OYB8O+B0+YO*+B*==8OG+88+0<Y=GR+0EO/FG@+O@+GOE7'-8DO-F>O@+GOB0E+QO-YOE8G-0@MQ-8DOB0O+B0+GO'=+'Q+O'B08+GOE++8-0RO*Q-+88+GO.+GE8+7 8<OY-0OYFEEOY+'GY-QEO-F>O@B+OE++8-0RO*Q-+88+GO@GF+7 +02O@-YB8OEB7'O@+GO+B0R-0RO=+>>0+8<</textarea> </br>${DE}Und hier noch Textschnipsel, wenn man sie alle sammelt bekommt man:${EN}And here are some text snippets, if you collect them all you get:${ALL} </br><textarea rows='8' cols='80' style='white-space: wrap;' >NM.. NNEDALESN HR.EBEZBSEZTM TUGTFOE SBCI E OHER RFFENSAEEE  H TZIE. FZETC D  AHEC NFNN  NRAU N URHCDOS AT GBLRHNNEIARINGMHANRBREILTDZ BCTSI  L  CGZERK GRTEA HKWUSHIO RRHEOID EN.OTNLEAASTGEUW NTZNETE.ND ISECEE AMDEIEKDT BHEFI RTSBTEAS . IAAMIUT STMGEEEEUE  US,RRFN EEWNUEO TEKHCREISVNEEDIMA RRMEEEUFSFEENAUWM. ESR  CCT NSREODAHUEL ENO TNE RM AOI    PNTTTA NNTR IAT TLLLAENAMMR PET EIEGAKIOLL  IECKE U HLEOH AROVIU HWRHBDIP</textarea> </br>${DE}Eure Aufgabe ist es nun eine statistische Analyse des verschlüsselten Textes mit einer statistischen Analyse des verwürfelten Textes zu vergleichen. Bei dem verschlüsselten Text wurden die Zeichen vom Leerzeichen bis zu Z permutiert. Bei dem verwürfelten Text wurde die Position der Buchstaben im Text verwürfelt. Nach statistischer Analyse muss man dann nur noch das Alphabet in beiden Fällen nach dem Vorkommen sortieren. Wenn man dann die Alphabete vergleicht, bekommt man den Entschlüsselungsschlüssel. Dies setzt voraus, dass jeder Buchstabe mit unterschiedlicher Häufigkeit vorkommt. Aber in diesem Falle war das Schicksal gnädig mit uns... </br>${EN}Your task is now to compare a statistical analysis of the encrypted text with a statistical analysis of the scrambled text. In the scrambled text, the characters from the space to Z were permuted. In the scrambled text, the position of the letters in the text was scrambled. After statistical analysis, one then only has to sort the alphabet according to occurrence in both cases. If one then compares the alphabets, one gets the decryption key. This assumes that each letter occurs with a different frequency. But in this case, fate was merciful with us... </br>${DE}Du kannst auch das ${EN}You can also watch the ${ALL}<a target='_blank' href='https://www.youtube.com/watch?v=EHDu5SzsGRE&list=PLEWVM-KBUSpmWSfyoFdD_hLWAY_9tTgi5&index=28'>Video</a>${DE} zum Rätsel anschauen, ber bitte schaut das Video mit der Lösung nicht gleich im Anschluss an. </br>${EN} corresponding to the riddle, but please do not watch the video afterwards with the solution right away. </br>`
											:
											T`${DE}Da ist ein verschlüsselter Text drin, er wurde rückwärts geschrieben:${EN}There's a coded text in there, it's been written backwards:${ALL} </br><textarea rows='8' cols='80' style='white-space: wrap;' >${DE}NEKCEURD GNATEES TFO${EN}DEEWAES SSERP YLNETFO${ALL}</textarea> </br>${DE}Kannst du ein Entschlüsslungsprogramm schreiben? Versuchs mal mit dem ${EN}Can you write a decryption programme? Try the ${ALL}<a target='_blank' href='https://makecode.microbit.org/#pub:_DCub8VgW8VX1'>Code</a>.`
									);
							}
							else {
								return T`<img src='bottlemessage.png'>${DE}Leider hat das mit der Torte nicht geklappt sie ist leider zerbrochen. Aber ich backe einfach nochmal eine. Wenn du dann das Problem gelöst hast öffne ich Dir die Flasche.${EN}Unfortunately, it didn't work out with the cake - it broke. But I'll just bake another one. When you have solved the problem, I will open the bottle for you.`
								break;
							}
							break;
						case "2":
							return T`${DE}Das ist Schade, aber bist du dir sicher? </br>Als Gegenleistung öffne ich dir auch deine Flasche.${EN}That's a pity, but are you sure? </br>In return, I'll also open your bottle.`;
							break;
						default:
							Commands.understood = false;
							continue;
					}
				}
			}
			else {
				return T`${DE}Hallo!${EN}Hello`;
			}
		}
		else {
			while (true) {
				let reply = yield T`${DE}Ach in dieser Bar geht aber auch echt alles verloren, </br>zuerst die Mini-Schirmchen, dann die Orangen und jetzt auch noch mein Tortenheber. </br>Oh Entschuldigung, ich habe dich nicht gesehen. </br>Kann ich dir helfen? <p style='color:#0f0;'>${["1"]} - Nein danke, mir geht es bestens. </br>${["2"]} - Ja, kannst du mir helfen diese Flasche zu öffnen?</p>${EN}Oh, everything gets lost in this bar, </br>first the mini umbrellas, then the oranges and now my cake server. </br>Oh sorry, I didn't see you. </br>Can I help you? <p style='color:#0f0;'>${["1"]} - No thanks, I'm fine. </br>${["2"]} - Yes, can you help me open this bottle?</p>`;
				switch (reply) {
					case "1":
						return T`${DE}Dann bis später.${EN}See you later.`
					case "2":
						return T`${DE}Würde ich liebend gerne machen, </br>aber vorher muss ich noch eine Torte backen. </br>Das wird aber echt schwer ohne meinen Tortenheber.${EN}I would love to make it, </br>but I have to bake a cake first. </br>But that will be really hard without my cake server.`
					case "123":
						barmann.tricked = true;
						return T`${DE}Oh du bist der Programmierer. Dann geht das auch ohne Tortenheber!${EN}Oh, you're the programmer. Then you can do it without a cake server!`
					default:
						Commands.understood = false;
						continue;
				}
			}
		}
	}
	let tortenliebhaber = new Person([T`${DE}Tortenliebhaber${EN}cake lover`, T`${DE}Torten Liebhaber`], T`${DE}ein Tortenliebhaber${EN}a cakelover`, { open: false });
	scene4.insert(tortenliebhaber);
	let kaugummi = new Item(T`${DE}Kaugummi${EN}Chewing gum`, T`${DE}Ein Stück Kaugummi.${EN}A piece of chewing gum.`)
	tortenliebhaber.insert(kaugummi);
	tortenliebhaber.dialog = async function* () {
		if (!this.has(kaugummi)) return T`${DE}Das ist echt ärgerlich, ohne den Tortenheber kann Ben mir ja gar nicht meine Lieblingstorte servieren.${EN}That's really annoying, without the cake server, Ben can't serve me my favourite cake.`;
		while (true) {
			let reply = yield T`${DE}Willst du ein Kaugummi? <p style='color:#0f0;'>${["1"]} - Ja. </br>${["2"]} - Nein</p>${EN}Do you want a chewing gum? <p style='color:#0f0;'>${["1"]} - Yes. </br>${["2"]} - No</p>`;
			switch (reply) {
				case T`${DE}ja${EN}yes`.toString():
				case "1":
					tortenliebhaber.open = true;
					Commands.actor.take(kaugummi)
					tortenliebhaber.open = false;
					return T`${DE}Bitte schön!${EN}Here you are!`;
				case T`${DE}nein${EN}no`.toString():
				case "2":
					return T`${DE}Tschüss!${EN}Bye!`;
				default:
					Commands.understood = false;
					continue;
			}
		}
	}
	let scene5 = new Scene(T`${DE}Stadt${EN}City`, T`<div class='flow'><img class='back' src='s5.png'><img id='s5artist1' src='s5artist1.png'><img id='s5artist2' src='s5artist2.png'><img id='s5seller1' src='s5seller1.png'><img id='s5seller2' src='s5seller2.png'><img id='s5tante1' src='s5tante1.png'><img id='s5tante2' src='s5tante2.png'></div>${DE}Du befindest dich auf einem kleinen Marktplatz in der Stadt. </br>Nach ${["Norden"]} geht es über Straße mit Ampel in den Dschungel, </br>nach ${["Süden"]} geht es zum Strand.${EN}You are in a small market place in the city. </br>To the ${["north"]}, there is a road with traffic lights leading into the jungle, </br>to the ${["south"]}, there is the beach.`)
	scene5.south = scene3;
	let verkaeufer = new Person(T`${DE}Verkäufer${EN}Seller`, T`${DE}ein Verkäufer${EN}a seller`);
	scene5.insert(verkaeufer);
	let muenzen = new Item(["1 Euro", "Euro", "€1", "1 €"], "Euro-Münzen");
	muenzen.value = 1;
	muenzen.golden = false;

	verkaeufer.insert(muenzen);

	verkaeufer.dialog = async function* () {
		while (true) {
			const reply = yield T`${DE}Kannst Du mir bei der Abrechnung helfen? <p style='color:#0f0;'>${["1"]} - Gerne. </br>${["2"]} - Nein Danke! </br>${["3"]} - Kann ich was kaufen?</p>${EN}Can you help me with the billing? <p style='color:#0f0;'>${["1"]} - Gladly. </br>${["2"]} - No thanks! </br>${["3"]} - Can I buy something?</p>`;
			switch (reply) {
				case "1":
					print(T`${DE}Super Danke! Wenn du 10 mal hintereinander richtig rechnest bekommst du ein Euro von mir als Dank. </br>${EN}Super thanks! If you calculate correctly 10 times in a row, you'll get a Euro from me as a thank you. </br>`)
					let richtig = 0;
					while (true) {
						let a;
						let b;
						if(Commands.understood!=false)
							a = randint(1, 10);
							b = randint(1, 10);
						}
						const reply = yield T`${DE}Was ist ${a}+${b}?${EN}What is ${a}+${b}?${ALL}</br><quiet>${["7",""]} ${["8",""]} ${["9",""]}</br>${["4",""]} ${["5",""]} ${["6",""]}</br>${["1",""]} ${["2",""]} ${["3",""]}</br>${["c","",""]} ${["0",""]} ${["ok"," "]}</quiet>`;
						if (parseInt(reply) == 4242) {
							if (this.has(muenzen)) {
								this.open = true;
								Commands.actor.take(muenzen);
								this.open = false;
							}
							muenzen.value = 3;
							if (muenzen.golden) {
								muenzen.title = [muenzen.value + T`${DE} Goldmünzen${EN} Gold coins`, T`${DE}Goldmünze${EN}Gold coin`, T`${DE}Goldmünzen${EN}Gold coins`, T`${DE}münzen${EN}coins`, T`${DE}münze${EN}coin`]
							}
							else muenzen.title = [muenzen.value + " Euros", "Euro", "Euros", "€" + muenzen.value, muenzen.value + " €"];
							return "you tricked me!"
						}
						if (!isNaN(parseInt(reply))) {
							let ans;
							if (a + b == parseInt(reply)) {
								richtig += 1;
								if (richtig >= 10) {
									print(T`${DE}Hier ein Euro. ${EN}Here one Euro. `)
									if (this.has(muenzen)) {
										this.open = true;
										Commands.actor.take(muenzen);
										this.open = false;
									}
									else {
										muenzen.value += 1;
										if (muenzen.golden) {
											muenzen.title = [muenzen.value + T`${DE} Goldmünzen${EN} Gold coins`, T`${DE}Goldmünze${EN}Gold coin`, T`${DE}Goldmünzen${EN}Gold coins`, T`${DE}münzen${EN}coins`, T`${DE}münze${EN}coin`]
										}
										else muenzen.title = [muenzen.value + " Euros", "Euro", "Euros", "€" + muenzen.value];
									}
									richtig = 0;
								}
								ans = yield T`${DE}Richtig! Weiter? <p style='color:#0f0;'>${["1"]} - Ja! <br>${["2"]} - Nein!</p>${EN}Right! Continue? <p style='color:#0f0;'>${["1"]} - Yes! <br>${["2"]} - No!</p>`;
							} else {
								richtig = 0;
								ans = yield T`${DE}Falsch! Weiter? <p style='color:#0f0;'>${["1"]} - Ja! <br>${["2"]} - Nein!</p>${EN}Wrong! Continue? <p style='color:#0f0;'>${["1"]} - Yes! <br>${["2"]} - No!</p>`;
							}
							switch (ans) {
								case "1":
								case T`${DE}ja${EN}yes`.toString():
									continue;
								case T`${DE}nein${EN}no`.toString():
								case "2":
									if (ich.has(nagellack) && nagellack.appliedtocoin) return T`<p style='color:#0f0;'>Ich male sie gleich golden an.</p>`
									else return T`${DE}Tschüss!${EN}Bye!`
								default:
									Commands.understood = false;
									continue;
							}
						}
						else{
							Commands.understood = false;
							continue;
						}
					}
					break;
				case "2":
					return T`${DE}Ich hätte Dich auch dafür bezahlt!${EN}I would have paid for it!`
				case "3":
					return T`${DE}Für ein paar Goldmünzen kann ich dir eine verschlossene Überraschungsholzbox verkaufen.${EN}For a few gold coins I can sell you a sealed surprise wooden box.`
				default:
					Commands.understood = false;
					continue;
			}
		}
	}
	let holzbox = new Item(T`${DE}Holzbox${EN}wooden box`, "", { openable: false, closable: true, open: false });
	let koffer = new Item(T`${DE}Koffer${EN}Suitcase`, "", { openable: false, closable: true, open: false });
	koffer.describe = function () {
		return T`${DE}Ein ${EN}A ` + (this.open ? T`${DE}offener Koffer.${EN}open suitcase.` : T`${DE}geschlossener Koffer.${EN}closed suitcase.`) + this.printcommands();
	}

	holzschluessel.insertApplyTarget(holzbox)
	holzbox.describe = function () {
		return T`${DE}Eine ${EN}A ` + (this.open ? T`${DE}offene Holzbox.${EN}open wooden box.` : T`${DE}geschlossene Holzbox.${EN}closed wooden box.`) + this.printcommands();
	}
	let nagel = new Item(T`${DE}Nagel${EN}Nail`, T`${DE}Ein rostiger Nagel.${EN}A rusty nail`, { applicable: true })
	let batterie = new Item(T`${DE}Batterie${EN}Battery`, T`${DE}Volle Mono-Batterie.${EN}A full Mono-Battery.`, { applicable: true });
	let kabel = new Item(T`${DE}Kabel${EN}Cable`, T`${DE}Stück isolierten Volldraht-Kabel.${EN}piece of insulated solid wire cable.`, { applicable: true, open: true });
	kabel.describe = function () {
		if (this.has(nagel) && this.has(batterie)) {

			return T`${DE}aktiver Elektromagnet${EN}active Electromagnet` + this.printcommands();
		}
		if (this.has(nagel)) {
			return T`${DE}Elektromagnet${EN}Electromagnet` + this.printcommands();
		}

		else return this.description;
	}
	kabel.insertApplyTarget(nagel);
	kabel.insertApplyTarget(batterie);

	kabel.giving = function (thing) {
		if (thing === batterie) {
			if (this.has(nagel)) this.title = [T`${DE}Elektromagnet${EN}Electromagnet`];
			return true;
		}
		if (thing === nagel) {
			this.title = [T`${DE}Kabel${EN}Cable`]
			return true;
		}
		return false;

	}
	let metallschluessel = new Item(T`${DE}Schlüssel${EN}key`, T`${DE}Ein Metall Schlüssel.${EN}A metal key.`, { applicable: true });
	kabel.insertApplyTarget(metallschluessel)
	metallschluessel.insertApplyTarget(koffer);
	metallschluessel.doapply = function (target) {
		if (target === koffer) {
			print(T`${DE}Der Koffer öffnet sich.${EN}The suitcase opens.`);
			target.openable = true;
			target.open = true;
			Commands.forward_command = T`${DE}b koffer${EN}l suitcase`
			//print(target.describe())
			return true;
		}
		return false;
	}

	kabel.doapply = function (target) {
		if (target === nagel) {
			this.take(target);
			this.title = [T`${DE}Elektromagnet${EN}Electromagnet`, T`${DE}Magnet${EN}Magnet`];
			print(this.describe())
			return true;
		}
		if (target === batterie) {
			if (this.has(nagel)) {
				this.take(target);
				this.title = [T`${DE}aktiver Elektromagnet${EN}active Electromagnet`, T`${DE}Elektromagnet${EN}Electromagnet`, T`${DE}Magnet${EN}Magnet`];
				print(this.describe())
				return true;
			}
			return false;
		}
		if (target === metallschluessel) {
			if (this.has(nagel) && this.has(batterie)) {
				Commands.actor.take(metallschluessel, true);
				print(T`${DE}Oh wow, jetzt hab ich den Schlüssel!${EN}Oh wow, now I have the key!`)
				return true;
			}
			if (this.has(nagel) && !this.has(batterie)) {
				print(T`${DE}Ich glaube der braucht noch Strom!${EN}I think it still needs power!`)
				return true;
			}
		}
	}

	holzbox.insert(nagel);
	holzbox.insert(batterie);
	holzbox.insert(kabel);
	verkaeufer.insert(holzbox);

	holzschluessel.doapply = function (target) {
		if (target === holzbox) {
			print(T`${DE}Die Holzbox öffnet sich. </br>${EN}The wood box opens. </br>`);
			target.openable = true;
			target.open = true;
			Commands.forward_command = T`${DE}b holzbox${EN}l wooden box`
			//print(target.describe())
			return true;
		}
		return false;
	}


	verkaeufer.receiving = function (thing) {
		if (thing == muenzen && muenzen.value >= 3 && muenzen.golden) {
			muenzen.value = 1;
			print(T`${DE}Alles klar! Hier hast du die Holzbox!${EN}All right! Here you have the wooden box!`);
			verkaeufer.open = true;
			Commands.actor.take(holzbox);
			verkaeufer.open = false;
			return true;
		}
		else {
			print(T`${DE}Ich will mindestens 3 Goldmünzen für die Holzbox.${EN}I want at least 3 gold coins for the wooden box.`)
			return false;
		}
	}
	let nagellack = new Item([T`${DE}Nagellack${EN}nail polish`, T`${DE}Goldener Nagellack${EN}Golden nail polish`], T`${DE}Goldener Nagellack.${EN}Golden nail polish.`, { dropable: false, applicable: true });
	nagellack.insertApplyTarget(muenzen)

	nagellack.appliedtocoin = false;
	nagellack.doapply = function (target) {
		if (target === muenzen) {
			this.appliedtocoin = true;
			muenzen.golden = true;
			muenzen.title = muenzen.value == 1 ?
				[muenzen.value + T`${DE} Goldmünze${EN} Gold coin`, T`${DE}Goldmünze${EN}Gold coin`, T`${DE}Goldmünzen${EN}Gold coins`, T`${DE}münzen${EN}coins`, T`${DE}münze${EN}coin`] :
				[muenzen.value + T`${DE} Goldmünzen${EN} Gold coins`, T`${DE}Goldmünze${EN}Gold coin`, T`${DE}Goldmünzen${EN}Gold coins`, T`${DE}münzen${EN}coins`, T`${DE}münze${EN}coin`]
			muenzen.description = T`${DE}Glitzernde gold Münzen.${EN}shiny gold coins.`
			print(T`${DE}Jetzt habe ich Goldmünzen!${EN}Now I have gold coins.`)
			return true;
		}
		else return false;
	}
	let tratschtante = new Person([T`${DE}Tratschtante${EN}Tattletale`, T`${DE}Tratsch Tante${EN}Tattletail`], T`${DE}eine Tratschtante${EN}a tattletale`);
	tratschtante.insert(nagellack);
	scene5.insert(tratschtante);
	tratschtante.receiving = function (thing) {
		if (thing == kaugummi) {
			print(T`${DE}Danke! Hier hast du den goldenen Nagellack dafür.${EN}Thank you! Here you have the golden nail polish for it.`);
			this.open = true;
			Commands.actor.take(nagellack);
			this.open = false;
			return true;
		}
		else return false;
	}
	tratschtante.dialog = async function* () {
		if (!this.has(nagellack)) return T`${DE}Psst, hör mal, ich muss dir was erzählen. </br>Der Verkäufer da hinten verlangt bei Touristen </br>den dreifachen Preis! </br>Lass dich nicht übers Ohr hauen!${EN}Shh, listen, I have something to tell you. </br>The seller back there charges tourists </br>three times the price! </br>Don't let yourself be taken for a ride!`;
		else return T`${DE}Schau mal mein toller goldener Nagellack. Meine Finger sehen richtig hübsch aus. Aber ich würde alles für Kaugummi geben.${EN}Look at my great golden nail polish. My fingers look really pretty. But I'd give anything for chewing gum.`;
	}
	let kuenstler = new Person(T`${DE}Künstler${EN}Artist`, T`${DE}ein Künstler${EN}an artist`);
	scene5.insert(kuenstler);
	let bild = new Item(T`${DE}Bild${EN}Picture`, T`${DE}Ein Kunstwerk.${EN}A piece of art.`);
	kuenstler.insert(bild)
	kuenstler.receiving = function (thing) {
		if (thing === muenzen) {
			Commands.forward_command = T`${DE}t künstler${EN}t artist`
			return false;
		}
	}
	kuenstler.dialog = async function* () {
		if (!this.has(bild)) return T`${DE}Ich brauche noch etwas Zeit für mein neues Kunstwerk.${EN}I still need some time for my new artwork.`
		while (true) {
			let reply = yield T`${DE}Dieses Bild kann man kaufen! </br>Hm, wieviel Euro soll ich verlangen? <p style='color:#0f0;'>${["1"]} - Nein Danke! </br>${["2"]} - Ich gebe dir all mein Geld</p>${EN}This picture can be bought! </br>Hm, how much euros should I ask for? <p style='color:#0f0;'>${["1"]} - No thanks! </br>${["2"]} - I'll give you all my money</p>`;
			switch (reply) {
				case "1":
					return T`${DE}Tschüss!${EN}Bye!`
				case "2":
					if (ich.has(muenzen) && muenzen.value >= 3 && muenzen.golden) {
						muenzen.value = 1;
						muenzen.title = [muenzen.value + T`${DE} Goldmünzen${EN} Gold coins`, T`${DE}Goldmünze${EN}Gold coin`, T`${DE}Goldmünzen${EN}Gold coins`, T`${DE}münzen${EN}coins`, T`${DE}münze${EN}coin`]
						verkaeufer.take(muenzen, true);
						verkaeufer.open = true;
						Commands.actor.take(bild);
						verkaeufer.open = false;
						return T`${DE}Das Kunstwerk gehört Dir!${EN}The artwork belongs to you!`
					}
					else if (!ich.has(muenzen)) return T`${DE}Witzbold, du hast doch gar kein Geld!${EN}Are you kidding? You don't have any money!`
					else return T`${DE}Das ist mir zu wenig! Ich will mindestens 3 Goldstücke!${EN}That's not enough! I want at least 3 gold coins!`
				default:
					Commands.understood = false;
					continue;
			}
		}
	}
	let scene6 = new Scene(T`${DE}Dschungel${EN}Jungle`, T`<div class='flow'><img class='back' src='s6.png'></div>${DE}Du befindest dich auf einem Pfad im Dschungel. </br>Nach ${["Norden"]} geht es zu einer Lichtung, </br>nach ${["Süden"]} geht es zur Stadt </br>und im ${["Westen"]} liegt der Eingang des Ureinwohnerdorfes.${EN}You are on a path in the jungle. </br>To the ${["north"]} is a clearing, </br>to the ${["south"]} is the town </br>and to the ${["west"]} is the entrance to the native tribe village.`)
	let kaputteAmpel = new Door(T`${DE}Ampel${EN}traffic light`, T`${DE}Eine kaputte Ampel.${EN}A broken traffic-light.`, { blocking: true, usable: true, speakable: true, locked: true });
	kaputteAmpel.use = function () {
		Commands.forward_command = T`${DE}t ampel${EN}t traffic light`
		return false;
	}
	kaputteAmpel.blockingvar = true;
	Object.defineProperty(kaputteAmpel, 'blocking', {
		get() { return MODE.pro ? false : this.blockingvar; },
		set(val) { this.blockingvar = val; },
		enumerable: true,
		configurable: true
	});
	kaputteAmpel.dialog = async function* () {
		if (MODE.pro) return T`${DE}Für dieses Spiel musst du einen Mintrobi haben. Du hast jedoch den C++ Programmierkurs gewählt. Weshalb dieses Rätsel übersprungen wird.${EN}For this game you must have a Mintrobi. However, you have chosen the C++ programming course. Therefore, this puzzle is skipped.`;
		var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
		if (!isChrome) {
			return T`<em style='color:#faa;'>${DE}Du musst einen modernen Chrome/Edge Browser verwenden damit das geht!${EN}You need to use a modern Chrome/Edge browser for this to work!${ALL}</em>\n`;
		}
		while (true) {
			const reply = yield T`${DE}Die Ampel muss repariert werden. Verwende dazu das Gehirn von Mintrobi. </br>Verbinde es mit dem USB-Kabel mit deinem Computer. Beim ersten mal musst du jetzt im Dialog das Gerät auswählen und auf OK clicken. <p style='color:#0f0;'>${["1"]} - Ok es ist alles verbunden! </br>${["2"]} - Ich wollte eigentlich gar nicht über die Ampel. </p>${EN}The traffic light needs to be repaired. Use the brain from Mintrobi. </br>Connect it to your computer with the USB cable. The first time, you must now select the device in the dialogue and click on OK. <p style='color:#0f0;'>${["1"]} - Ok, everything is connected! </br>${["2"]} - I didn't actually want to cross the traffic light.</p>`
			switch (reply) {
				case "1":
					while (true) {
						const reply2 = yield T`${DE}Als erstes musst du den Taster für die Fußgängerampel reparieren. <p style='color:#0f0;'>${["1"]} - Ok los gehts. </br>${["2"]} - Teste die Ampel (Drücke innerhalb von 10 Sekunden auf die A Taste) </br>${["3"]} - Ich habs mir anders überlegt, ich wollte eigentlich gar nicht über die Ampel.</p>${EN}First you have to fix the button for the pedestrian traffic light. <p style='color:#0f0;'>${["1"]} - Ok let's go. </br>${["2"]} - Test the traffic light (press the A button within 10 seconds) </br>${["3"]} - I changed my mind, I didn't really want to go through the traffic light.</p>.`;
						let trick = false;
						switch (reply2) {
							case "1":
								window.open("https://makecode.microbit.org/#pub:_4Mm6dtfmVTY5", "_blank")?.focus();
								break;
							case "123":
								trick = true;
							case "2":
								let val = "";
								val = await readMicrobit()
								if (trick) val = "111";
								console.log(val);
								if (val == "") {
									yield T`${DE}10 Sekunden sind vorbei. Versuchs nochmal. Drücke [ENTER].${EN}10 seconds have passed. Try again. Press [ENTER].`
									continue;
								}
								else if (val.startsWith("1")) {
									while (true) {
										const reply3 = yield T`${DE}Jetzt ist noch die Auto-Ampel kaputt. Alle Lampen müssen ersetzt werden. Dazu musst du Pin 0 mit einem Beinchen des 56 Ohm Widerstands (grün blau schwarz gold braun) verbinden. </br>Der Widerstand ist wichtig, er schützt die Leuchtdiode, das ist wie ein Wasserhahn, den man nicht ganz Aufdreht, der reduziert den Strom. </br>An das andere Bein des widerstands kommt das lange Beinchen der roten  </br>Leuchtdiode. Leuchtdioden leuchten nur wenn man sie richtig herum anschließt. </br>Das kurze Beinchen, da ist auch eine Abflachung am Gehäuse der Leuchtdiode musst du dann mit GND verbinden.In gleicher Weise verfahre mit Pin 1 und der gelben Leuchtdiode und mit Pin 2 und der grünen Leuchtdiode. </br><img width='80%' src='ampel.png'><p style='color:#0f0;'>${["1"]} - Ok es ist alles verbunden! </br>${["2"]} - Ich wollte eigentlich gar nicht über die Ampel. </p>${EN}Now the traffic lights are broken. All lamps must be replaced. To do this, connect pin 0 to one leg of the 56 Ohm resistor (green blue black gold brown). </br>The resistor is important, it protects the light emitting diode, it's like a tap that you don't turn on all the way, it reduces the current. </br>The long leg of the red  </br>light-emitting diode is connected to the other leg of the resistor. Light-emitting diodes only light up if you connect them the right way round. </br>The short leg, there is also a flat on the housing of the light emitting diode, must then be connected to GND. Proceed in the same way with pin 1 and the yellow light emitting diode and with pin 2 and the green light emitting diode. </br><img width='80%' src='ampel.png'><p style='color:#0f0;'>${["1"]} - Ok, it is all connected! </br>${["2"]} - I didn't actually want to go through the traffic light.</p>`
										switch (reply3) {
											case "1":
												while (true) {
													const reply4 = yield T`${DE}Jetzt musst Du noch den Code weiterschreiben. Die Ampel bekommt per usb die Zeichen: </br>${EN}Now you have to continue writing the code. The traffic light receives the characters: </br>${DE}s für stop also rot </br>${EN}s for stop indicated by red </br>${DE}b für bereit also gelb </br>${EN}b for ready indicated by yellow </br>${DE}f für fahren also grün </br>${EN}f for drive indicated by green${ALL} <p style='color:#0f0;'>${DE}${["1"]} - Ok, ich bin bereit zum Programmieren </br>${EN}${["1"]} - Ok, I am ready to program </br>${DE}${["2"]} - Das Programm ist fertig. Ich will die Auto-Ampel testen. </br>${EN}${["2"]} - The programme is finished. I want to test the traffic light. </br>${DE}${["3"]} - Ich wollte eigentlich gar nicht über die Ampel.${EN}${["3"]} - I didn't actually want to go through the traffic lights.${ALL}</p>`;
													let trick = false;
													switch (reply4) {
														case "1":
															window.open("https://makecode.microbit.org/#pub:_REjD0A9HE4m9", "_blank")?.focus();
															break;
														case "123":
															trick = true;
														case "2":
															while (true) {
																let result = await writeMicrobit("b\n");
																if (!result && !trick) return T`${DE}Fehler in der Kommunikation.Versuche es nochmal von vorne.${EN}Error in communication. Try it again from the beginning.`
																let farbe = yield T`${DE}Welche Farbe hat die Ampel?${EN}Which color does the traffic light show?${ALL} <p style='color:#0f0;'>${DE}${["1"]} - Rot </br>${EN}${["1"]} - Red </br>${DE}${["2"]} - Gelb </br>${EN}${["2"]} - Yellow </br>${DE}${["3"]} - Grün </br>${EN}${["3"]} - Green </br>${DE}${["4"]} - Ich mache später weiter.${EN}${["4"]} - I'll continue later${ALL}</p>`;
																if (farbe == "4") return T`${DE}Dann bis später.${EN}.See you then.`;
																if (farbe != "2") {
																	yield T`${DE}Das war nicht ganz richtig. Überprüfe das Programm und die Verkablung. Drücke [ENTER] um weiterzumachen.${EN}That was not quite right. Check the programme and the wiring. Press [ENTER] to continue.`;
																	continue;
																}

																result = await writeMicrobit("s\n");
																if (!result && !trick) return T`${DE}Fehler in der Kommunikation.Versuche es nochmal von vorne.${EN}Error in communication. Try it again from the beginning.`;
																farbe = yield T`${DE}Richtig! Welche Farbe hat die Ampel jetzt?${EN}Right! Which color does the traffic light show now?${ALL} <p style='color:#0f0;'>${DE}${["1"]} - Rot </br>${EN}${["1"]} - Red </br>${DE}${["2"]} - Gelb </br>${EN}${["2"]} - Yellow </br>${DE}${["3"]} - Grün </br>${EN}${["3"]} - Green </br>${DE}${["4"]} - Ich mache später weiter.${EN}${["4"]} - I'll continue later${ALL}</p>`;
																if (farbe == "4") return T`${DE}Dann bis später.${EN}.See you then.`;
																if (farbe != "1") {
																	yield T`${DE}Das war nicht ganz richtig. Überprüfe das Programm und die Verkablung. Drücke [ENTER] um weiterzumachen.${EN}That was not quite right. Check the programme and the wiring. Press [ENTER] to continue.`;
																	continue;
																}

																result = await writeMicrobit("f\n");
																if (!result && !trick) return T`${DE}Fehler in der Kommunikation.Versuche es nochmal von vorne.${EN}Error in communication. Try it again from the beginning.`;
																farbe = yield T`${DE}Genau! Und welche Farbe hat die Ampel nun?${EN}That's right! And which color does the traffic light show now?${ALL} <p style='color:#0f0;'>${DE}${["1"]} - Rot </br>${EN}${["1"]} - Red </br>${DE}${["2"]} - Gelb </br>${EN}${["2"]} - Yellow </br>${DE}${["3"]} - Grün </br>${EN}${["3"]} - Green </br>${DE}${["4"]} - Ich mache später weiter.${EN}${["4"]} - I'll continue later${ALL}</p>`;
																if (farbe == "4") return T`${DE}Dann bis später.${EN}.See you then.`;
																if (farbe != "3") {
																	yield T`${DE}Das war nicht ganz richtig. Überprüfe das Programm und die Verkablung. Drücke [ENTER] um weiterzumachen.${EN}That was not quite right. Check the programme and the wiring. Press [ENTER] to continue.`;
																	continue;
																}
																kaputteAmpel.blocking = false;
																return T`${DE}Super. Du hast die Ampel repariert und kannst jetzt nach ${["Norden"]} in den Djungel.${EN}Great. You've fixed the traffic lights and can now head ${["north"]} into the jungle.`
															}
															break;

														case "3":
															return T`${DE}Dann auf ein andermal!${EN}I'll see you around!`;
														default:
															Commands.understood = false;
															continue;
													}
												}
											case "2":
												return T`${DE}Dann auf ein andermal!${EN}I'll see you around!`;
											default:
												Commands.understood = false;
												continue;
										}
									}
								}
							case "3":
								return T`${DE}Dann auf ein andermal!${EN}I'll see you around!`;
							default:
								Commands.understood = false;
								continue;
						}
					}
				case "2":
					return T`${DE}Dann auf ein andermal!${EN}I'll see you around!`;
				default:
					Commands.understood = false;
					continue;
			}
		}
	}
	let kaputteAmpel2 = new Door(T`${DE}Ampel${EN}traffic light`, T`${DE}Ein Ampel bei der wieder was kaputt ist.${EN}A traffic light where something is broken again.`, { blocking: true, usable: true, speakable: true, locked: true });
	kaputteAmpel2.blockingvar = true;
	Object.defineProperty(kaputteAmpel2, 'blocking', {
		get() { return MODE.pro ? false : this.blockingvar; },
		set(val) { this.blockingvar = val; },
		enumerable: true,
		configurable: true
	});
	kaputteAmpel2.use = function () {
		Commands.forward_command = T`${DE}t ampel${EN}t traffic light`
		return false;
	}
	kaputteAmpel2.dialog = async function* () {
		if (MODE.pro) return T`${DE}Für dieses Spiel musst du einen Mintrobi haben. Du hast jedoch den C++ Programmierkurs gewählt. Weshalb dieses Rätsel übersprungen wird.${EN}For this game you must have a Mintrobi. However, you have chosen the C++ programming course. Therefore, this puzzle is skipped.`;
		var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
		if (!isChrome) {
			return T`<em style='color:#faa;'>${DE}Du musst einen modernen Chrome/Edge Browser verwenden damit das geht!${EN}You need to use a modern Chrome/Edge browser for this to work!${ALL}</em>\n`;;
		}
		while (true) {
			const reply = yield T`${DE}Die Ampel muss wieder repariert werden. Diesmal soll die gelbe Leuchtdiode kaputt sein. Kannst Du mit der Leuchtdiode die 4 Beinchen hat gelb durch Farbmischung herstellen. Hier erfährst du mehr über Farbmischung ${EN}The traffic lights need to be repaired again. This time the yellow light-emitting diode is supposed to be broken. Can you use the light-emitting diode that has 4 legs to make yellow by mixing colours? Learn more about colour mixing here. ${ALL}<a target='_blank' href='https://www.youtube.com/embed/5PQ_foxxoKM?autoplay=1'>Video</a>. ${DE}Verwende dazu das Gehirn von Mintrobi. </br>Verbinde es mit dem USB-Kabel mit deinem Computer. Beim ersten mal musst du jetzt im Dialog das Gerät auswählen und auf OK clicken. </br>Verkabele alles wie in der Abbildung${EN}Use the brain from Mintrobi. </br>Connect it to your computer with the USB cable. The first time you do this, select the device in the dialogue and click OK. </br> Connect everything as shown in the picture ${ALL} <img width='80%' src='multifarbe.png'><p style='color:#0f0;'>${DE}${["1"]} - Wie soll man denn aus rot, grün und blau die Farbe gelb mischen? </br>${EN}${["1"]} - How are you supposed to mix red, green and blue to make yellow? </br>${DE}${["2"]} - Ok, es ist alles verbunden! </br>${EN}${["2"]} - Ok, it is all connected! </br>${DE}${["3"]} - Ich wollte eigentlich gar nicht über die Ampel.${EN}${["3"]} - I didn't actually want to go through the traffic light.${ALL}</p>`;
			switch (reply) {
				case "1":
					window.open("https://www.youtube.com/embed/5PQ_foxxoKM?autoplay=1", "_blank")?.focus();
					continue;
				case "2":
					while (true) {
						const reply4 = yield T`${DE}Jetzt musst Du noch den Code weiterschreiben. Die Ampel bekommt per usb die Zeichen: </br>${EN}Now you have to continue writing the code. The traffic light receives the characters via usb: </br>${DE}r1 für rotes Licht an </br>${EN}r1 for red light on </br>${DE}r0 für rotes Licht aus </br>${EN}r0 for red light off </br>${DE}g1 für grünes Licht an </br>${EN}g1 for green light on </br>${DE}g0 für grünes Licht aus </br>${EN}g0 for green light off </br>${DE}b1 für blaues Licht an </br>${EN}b1 for blue light on </br>${DE}b0 für blaues Licht aus </br>${EN}b0 for blue light off </br>${ALL} <p style='color:#0f0;'>${DE}${["1"]} - Ok, ich bin bereit zum Programmieren </br>${EN}${["1"]} - Ok, I am ready to program </br>${DE}${["2"]} - Programm ist fertig. Ich will die Farb-Ampel testen </br>${EN}${["2"]} - Programme is finished. I want to test the colour traffic light. </br>${DE}${["3"]} - Ich wollte eigentlich gar nicht über die Ampel.${EN}${["3"]} - I didn't actually want to go through the traffic light.${ALL}</p>`;
						let trick = false;
						switch (reply4) {
							case "1":
								window.open("https://makecode.microbit.org/#pub:_fCvCeLT1h7tH", "_blank")?.focus();
								break;
							case "123":
								trick = true;
							case "2":
								let red = false;
								let green = false;
								let blue = false;
								while (true) {
									let farbe = yield T`${DE}Sende Befehl an Gehirn von Mintrobi?${EN}Send command to brain of Mintrobi?${ALL} <p style='color:#0f0;'>${DE}${["r1"]} - für rotes Licht an </br>${EN}${["r1"]} - for red light on </br>${DE}${["r0"]} - für rotes Licht aus </br>${EN}${["r0"]} - for red light off </br>${DE}${["g1"]} - für grünes Licht an </br>${EN}${["g1"]} - for green light on </br>${DE}${["g0"]} - für grünes Licht aus </br>${EN}${["g0"]} - for green light off </br>${DE}${["b1"]} - für blaues Licht an </br>${EN}${["b1"]} - for blue light on </br>${DE}${["b0"]} - für blaues Licht aus </br>${EN}${["b0"]} - for blue light off </br>${DE}${["1"]}  - Ich habe gelb </br>${EN}${["1"]} - I have realized yellow </br>${DE}${["2"]} - Ich mache später weiter.${EN}${["2"]} - I will continue later.${ALL}</p>`;
									switch (farbe) {
										case "r0":
											red = false;
											break;
										case "r1":
											red = true;
											break;
										case "g0":
											green = false;
											break;
										case "g1":
											green = true;
											break;
										case "b0":
											blue = false;
											break;
										case "b1":
											blue = true;
											break;
										case "1":
										case "2":
											break;
										default:
											print(T`${DE}Das vertehe ich nicht, versuchs nochmal!${EN}I didn't get that, try again.`)
											continue;
									}
									if (farbe == "2") return T`${DE}Dann bis später.${EN}.See you then.`;
									if (farbe == "1") {
										if (red && green && !blue) {
											kaputteAmpel2.blocking = false;
											return T`${DE}Genau! Richtig wenn man rot und grün mischt bekommt man gelb. Die Ampel ist jetzt wieder ganz.${EN}Exactly! That's right, if you mix red and green you get yellow. The traffic light is now working again.`
										}
										else {
											yield T`${DE}Das war nicht ganz richtig. Überprüfe das Programm und die Verkablung. Drücke [ENTER] um weiterzumachen.${EN}That was not quite right. Check the programme and the wiring. Press [ENTER] to continue.`;
											continue;
										}
									}
									let result = await writeMicrobit(farbe + "\n");
									if (!result && !trick) return T`${DE}Fehler in der Kommunikation.Versuche es nochmal von vorne.${EN}Error in communication. Try it again from the beginning.`;
								}
								break;
							case "3":
								return T`${DE}Dann auf ein andermal!${EN}I'll see you around!`;
							default:
								Commands.understood = false;
								continue;
						}
					}
				case "3":
					return T`${DE}Dann auf ein andermal!${EN}I'll see you around!`;
				default:
					Commands.understood = false;
					continue;
			}
		}
	}
	scene6.south = scene5;
	scene5.northblock = kaputteAmpel;
	scene5.insert(kaputteAmpel)
	let scene7 = new Scene(T`${DE}Lichtung${EN}Clearance`, T`<div class='flow'><img class='back' src='s7.png'><img id='s7forscher1' src='s7forscher1.png'><img id='s7forscher2' src='s7forscher2.png'></div>${DE}Du befindest dich auf einer Lichtung im Dschungel. </br>Nach ${["Süden"]} geht es zurueck zum Dschungelpfad.${EN}You are in a clearance in the jungle. </br>To the ${["south"]} you go back to the jungle path.`)
	scene7.south = scene6;
	scene6.southblock = kaputteAmpel2;
	scene6.insert(kaputteAmpel2);
	let kostuem = new Item(T`${DE}Kostüm${EN}Costume`, T`<img src='kostuem.png'>${DE}eine Kostüm${EN}a costume`, { open: true, usable: true });
	kostuem.use = function () {
		Commands.forward_command = T`${DE}m Kostüm${EN}t costume`
		return true;
	}
	koffer.insert(kostuem)
	let Forscher = new Person(T`${DE}Forscher${EN}Scientist`, T`${DE}ein Forscher${EN}a scientist`);
	scene7.insert(Forscher);
	let sonnenuhranleitung = new Item([T`${DE}Sonnenuhranleitung${EN}Sundial plan`, T`${DE}Sonnenuhr Anleitung${EN}Sundialplan`], T`${DE}Um das Spiel zu lösen musst Du dieses Projekt nicht unbedingt durchführen. </br>${EN}You don't have to do this project to solve the game. </br>${DE}Falls du Lust hast und es draußen sonnig ist, dann baue mit dem Gehirn von Mintrobi eine Sonnenuhr. Du brauchst nur noch ein Wattestäbchen. </br>${EN}If you feel like it and it's sunny outside, make a sundial with Mintrobi's brain. All you need is a cotton bud. </br>${DE}Hier ist die ${EN}Here is the ${ALL}<a target='_blank' href='https://microbit.eeducation.at/wiki/Sonnenuhr_L%C3%B6sung'>${DE}Anleitung${EN}Instruction${ALL}</a>.`)
	scene7.insert(sonnenuhranleitung)
	Forscher.insert(koffer);
	Forscher.dialog = async function* () {
		if (this.has(koffer)) {
			while (true) {
				let reply;
				if (!MODE.pro){
					reply = yield T`${DE}Hallo, guten Tag. ${EN}Hello, good day. ${ALL}<p style='color:#0f0;'>${DE}${["1"]} - Hallo, wer sind Sie denn? </br>${EN}${["1"]} - Hello, who are you? </br>${DE}${["2"]} - Wie werde ich ins Dorf der Ureinwohner hereingelassen? </br>${EN}${["2"]} - How will I be let into the native tribe village? </br>${DE}${["3"]} - Wie kann ich Dir behilflich sein?</p>${EN}${["3"]} - How can I be of service to you?</p>`;
				}else{
					reply = yield T`${DE}Hallo, guten Tag. ${EN}Hello, good day. ${ALL}<p style='color:#0f0;'>${DE}${["1"]} - Hallo, wer sind Sie denn? </br>${EN}${["1"]} - Hello, who are you? </br>${DE}${["2"]} - Wie werde ich ins Dorf der Ureinwohner hereingelassen? </br>${EN}${["2"]} - How will I be let into the native tribe village?</p>`;
				}
				switch (reply) {
					case "1":
						return T`${DE}Ich bin Sir Ernest Wordsworth, </br>meines Zeichens Wissenschaftler und Ethnologe, </br>ich erforsche den hiesigen Stamm der Ureinwohner.${EN}I am Sir Ernest Wordsworth, </br>a scientist and ethnologist, </br>I am researching the local native tribe.`
					case "2":
						if(!MODE.pro){
							return T`${DE}Es ist mir noch nicht gelungen Einlass gewährt zu bekommen. </br>Meine bisherigen Forschungen habe ich Beobachtungen </br>aus hoch gelegenen Baumwipfeln zu verdanken, aus denen ich </br>über den Zaun, der das Dorf umgibt spähen konnte. </br>Doch mit deiner Statur ist eventuell möglich dich als einer </br>der Ihrigen auszugeben, wenn du dich entsprechend verkleidest.${EN}I have not yet succeeded in gaining admittance. </br>I owe my research so far to observations </br>from high up in the treetops, from which I have been able </br>to peer over the fence surrounding the village. </br>But with your stature, it may be possible </br>to pass yourself off as one of their own if you disguise yourself accordingly.`
						}
						else{
							koffer.open=true;
							Commands.actor.take(kostuem);
							koffer.open = false;
							return T`${DE}Es ist mir noch nicht gelungen Einlass gewährt zu bekommen. </br>Meine bisherigen Forschungen habe ich Beobachtungen </br>aus hoch gelegenen Baumwipfeln zu verdanken, aus denen ich </br>über den Zaun, der das Dorf umgibt spähen konnte. </br>Doch mit deiner Statur ist eventuell möglich dich als einer </br>der Ihrigen auszugeben, wenn du dich entsprechend verkleidest. Diese Maske könnte dir dabei helfen.${EN}I have not yet succeeded in gaining admittance. </br>I owe my research so far to observations </br>from high up in the treetops, from which I have been able </br>to peer over the fence surrounding the village. </br>But with your stature, it may be possible </br>to pass yourself off as one of their own if you disguise yourself accordingly. This mask might help you.`
						}
					case "3":
						if(!MODE.pro){
							return T`${DE}Ich würde mir ja so gerne ein Bild von dem Künstler in der Stadt leisten. Aber leider habe ich all mein Geld für die Forschung ausgegeben. Das einzige was ich im Tausch anbieten kann ist ein Koffer, den ich beim Ureinwohnerdorf gefunden habe. Leider bekomme ich den jedoch nicht auf. Daher will ihn auch keiner.${EN}I would  love to afford a painting by the artist in the city. But unfortunately I have spent all my money on research. The only thing I can offer in exchange is a suitcase I found at the native village. Unfortunately, I can't get it open. That's why no one wants it.`
						}
					default:
						Commands.understood = false;
						continue;
				}
			}
		} else {
			return T`${DE}Wissenschaft ist wunderbar!${EN}Science is wonderful!`;
		}
	}
	Forscher.receiving = function (thing) {
		if (thing === bild) {
			print(T`${DE}Oh wow genau das Bild wollte ich. Gerne gebe ich dir im Tausch den Koffer.${EN}Oh wow, that's exactly the picture I wanted. I'd be happy to give you the suitcase in exchange.`);
			this.open = true;
			Commands.actor.take(koffer);
			this.open = false;
			return true;
		}
		print(T`${DE}Nein behalte das. Das ist für dich.${EN}No, you keep that. This is for you.`);
		return false;
	}
	let scene8 = new Scene(T`${DE}Eingang zum Ureinwohnerdorf${EN}Entry to the village of the native tribe`, "")
	let holzstumpf = new Item([T`${DE}Holzstumpf${EN}wooden stump`, T`${DE}Holzstumpf${EN}wooden stamp`], T`${DE}Ein Holzstumpf mit tiefen Spalt.${EN}A wooden stump with a deep slit.`, { takeable: false, dropable: false, open: true })
	holzstumpf.insert(metallschluessel);
	eimer.insertApplyTarget(holzstumpf);
	holzstumpf.giving = function (thing) {
		print(T`${DE}Der Spalt ist zu tief!${EN}The slit is too deep`);
		return false;
	}
	holzstumpf.receiving = function (thing) {
		print(T`${DE}Besser nicht, sonst ists weg.${EN}Better not, otherwise it's gone.`)
		return false;
	}
	scene8.insert(holzstumpf)
	scene8.east = scene6;
	let tuer = new Door(T`${DE}Tür${EN}Door`, T`${DE}Eine verschlossene Tür.${EN}A locked door.`, { blocking: true })
	let torwache = new Person(T`${DE}Torwache${EN}Guard`, T`${DE}eine Torwache${EN}a gate guard`);
	scene8.insert(torwache);
	scene8.northblock = tuer;
	scene8.describe = function () {
		if (tuer.blocking) {
			return T`<div class='flow'><img class='back' src='s8.png'><img id='s8wache1' src='s8wache1.png'><img id='s8wache2' src='s8wache2.png'><img id='s8torzu' src='s8torzu.png'><img id='s8schild' src='s8schild.png'></div>${DE}Du bist im Dschungel und vor dir </br>baut sich eine große Holzwand auf der sich oben </br>ein Ureinwohner als Wache postiert hat. </br>Nach ${["Osten"]} geht es zurueck zum Dschungelpfad. </br>Tipp: Wenn du die Torwache nicht verstehst, wird dir der Forscher vielleicht helfen.${EN}You are in the jungle and in front of you </br>there is a big wooden wall on top of which </br>a native person has posted himself as a guard. </br>To the ${["east"]} it goes back to the jungle path. </br>Tip: If you don't understand the gate guard, the explorer might help you.` + this.printcommands();
		}
		else return T`<div class='flow'><img class='back' src='s8.png'><img id='s8wache1' src='s8wache1.png'><img id='s8wache2' src='s8wache2.png'><img id='s8torauf' src='s8torauf.png'><img id='s8schild' src='s8schild.png'></div>${DE}Du bist im Dschungel und vor dir </br>baut sich eine große Holzwand auf der sich oben </br>ein Ureinwohner als Wache postiert hat. </br>Nach ${["Osten"]} geht es zurueck zum Dschungelpfad. </br>Das Tor nach ${["Norden"]} ist offen. </br>${EN}You are in the jungle and in front of you </br>there is a big wooden wall on top of which </br>a native person has posted himself as a guard. </br>To the ${["east"]} you go back to the jungle path. </br>The gate to the ${["north"]} is open. </br>` + this.printcommands();
	}
	torwache.dialog = async function* () {
		if (Commands.actor.has(kostuem)) {
			if (tuer.blocking) {
				let reply = yield T`${DE}Hallo, Kumpel. </br>Ich dachte zuerst du bist schon wieder einer von diesen </br>bescheuerten Städtern, die uns immer wieder auf </br>die Nerven gehen. Aber manche verkleiden sich, </br>und da wir von klein auf rechnen lernen, </br>und da wir von klein auf rechnen lernen, </br>fällt es uns leicht ${EN}Hello, buddy. </br>At first I thought you were another one of those </br>stupid townies who always get on </br>our nerves. But some dress up, </br>and since we learn to count from a young age, </br>it is easy for us to ` + (MODE.pro ? T`${DE}die 20te Fibonacci Zahl zu schnell im Kopf zu berechnen${EN}calculate the 20th Fibonacci number quickly in your head` : T`${DE}alle zahlen von 0 bis 10 schnell im Kopf zusammenzuzählen${DE}add all numbers from 0 to 10 in your head`) + T`${DE} </br>und sie in das </br>Zahlenschloss einzugeben. Und spätestens daran </br>scheitern die bescheuerten Städter immer. </br>Hahaha! Hast du den Code berechnet? Das kann dir helfen: ${EN} </br>and enter them into the </br>combination lock. And that </br>is the latest thing the stupid city dwellers always fail at. </br>Hahaha! Have you calculated the code? That could help you: ` + (MODE.pro ? "<a target='_blank' href='https://www.youtube.com/watch?v=5cE_HfsLpP0&list=PLEWVM-KBUSpmWSfyoFdD_hLWAY_9tTgi5&index=22'>Video</a>" : "<a target='_blank' href='https://makecode.microbit.org/#pub:_gCb2aFRTi9M6'>Code</a>") + T`${DE} </br>Wenn ja dann sage ihn mir doch:${EN} </br>If so, then tell me:${ALL}</br><quiet>${["7",""]} ${["8",""]} ${["9",""]}</br>${["4",""]} ${["5",""]} ${["6",""]}</br>${["1",""]} ${["2",""]} ${["3",""]}</br>${["c","",""]} ${["0",""]} ${["ok"," "]}</quiet>`;
				if (reply === (MODE.pro ? "6765" : "55")) {
					tuer.blocking = false;
					return T`<img src='s8block.png'>${DE}Code akzeptiert. Das Tor nach ${["Norden"]} öffnet sich. </br>${EN}Code accepted. The gate to the ${["north"]} opens. </br>` + scene8.describe();
				}
				else return T`<img src='s8block.png'>${DE}Falscher Code!${EN}Wrong code!`
			}
			else {
				return T`${DE}Hallo, Kumpel!${EN}Hi, buddy!`;
			}
		}
		else {
			return "Ugga bugga, blubliblah! Impostor!"
		}
	}
	let scene9 = new Scene(T`${DE}Ureinwohnerdorf${EN}Village of native tribe`, T`<div class='flow'><img class='back' src='s9.png'><img id='s9pina1' src='s9pina1.png'><img id='s9pina2' src='s9pina2.png'><img id='s9mojito1' src='s9mojito1.png'><img id='s9mojito2' src='s9mojito2.png'><img id='s9daiquiri3' src='s9daiquiri3.png'><img id='s9daiquiri1' src='s9daiquiri1.png'><img id='s9daiquiri2' src='s9daiquiri2.png'><img id='s9mauer' src='s9mauer.png'></div>${DE}Du bist im Dorf der Ureinwohner. </br>Nach ${["Süden"]} geht es zurück zum Eingang. </br>${EN}You are in the village of the native tribe. </br>To the ${["south"]} you can go back to the entrance. </br>`);
	scene9.south = scene8;
	let pina = new Person(["Pina", "Pina Colada"], T`${DE}eine Ureinwohnerin${EN}a native woman`);
	let mojito = new Person("Mojito", T`${DE}ein Ureinwohner${EN}a native man`);
	let daiquiri = new Person(["Daiquiri", "Daikiri", T`${EN}Dietary`], T`${DE}ein Ureinwohner mit einem Problem${EN}a native man with a problem`);
	scene9.insert(pina);
	scene9.insert(mojito);
	scene9.insert(daiquiri);
	pina.dialog = async function* () {
		return T`${DE}Uiui, eine neue Maske, schnieke Mann.${EN}Oooh, a new mask, really beautiful.`;
	}
	mojito.dialog = async function* () {
		return T`${DE}Hehe, mein Freund von nebenan hat </br>auf seinem Kopf so ein komisches silbernes Teil stecken, </br>das sieht total bescheuert aus!${EN}Hehe, my friend next door has </br>some weird silver thing stuck on his head, </br>it looks totally stupid!`;
	}
	let tortenheber = new Item(T`${DE}Tortenheber${EN}Cake server`, T`<img src='tortenheber.png'>${DE}ein Tortenheber${EN}a cake server`);
	daiquiri.insert(tortenheber);
	daiquiri.dialog = async function* () {
		if (this.has(tortenheber)) {
			while (true) {
				let reply = yield T`${DE}Ich bin so verzweifelt, </br>ich komme einfach nicht weiter! </br>Die Nachbarn lachen schon alle über mich, </br>ich weiss es genau! Meine Frau wird mich bestimmt verlassen, </br>wenn ich es nicht los werde! <p style='color:#0f0;'>${["1"]} - Kann ich dir irgendwie helfen. </br>${["2"]} - Nee ich habe keine Zeit!</p>${EN}I am so desperate, </br>I just can't get on! </br>The neighbours are all laughing at me already, </br>I know it for sure! My wife will leave me for sure, </br>if I don't get rid of it! <p style='color:#0f0;'>${["1"]} - Can I help you somehow. </br>${["2"]} - No, I do not have time!</p>`;
				switch (reply) {
					case "1":
						while (true) {
							let reply2 = yield T`${DE}Das wäre sehr nett! Ich bin gestern mit diesem </br>seltsamen silbernen Teil auf dem Kopf aufgewacht, </br>aber ich komme nicht daran ohne meinen Kopfschmuck zu zerstören. </br>Bitte mach das weg!?! </br><p style='color:#0f0;'>${["1"]} - Kein Problem </br>${["2"]} - Nee keine Lust!</p>${EN}That would be very nice! I woke up yesterday with this </br>strange silver thing on my head, </br>but I can't get to it without destroying my headdress. </br>Please make it go away!?! </br><p style='color:#0f0;'>${["1"]} - No problem </br>${["2"]} - Nah don't feel like it!</p>`;
							switch (reply2) {
								case "1":
									this.open = true;
									Commands.actor.take(tortenheber);
									this.open = false;
									return T`${DE}Vielen Dank. Du kannst das Ding behalten. Sieht aus wie ein Tortenheber! </br>${EN}Thank you very much. You can keep that thing. It looks like a cake server! </br>` + tortenheber.describe()
								case "2":
									return T`${DE}Du hättest das Teil behalten können. O hilf mir doch jemand...${EN}You could have kept that thing. O somebody help me...`
								default:
									Commands.understood = false;
									continue;
							}
						}
						break;
					case "2":
						return T`${DE}Unhilfsbereit die Jugend...${EN}Unhelpful youth...`
					default:
						Commands.understood = false;
						continue;
				}
			}
		} else {
			return T`${DE}Danke nochmals.${EN}Thanks again.`;
		}
	}
	let scene10 = new Scene(T`${DE}Geheimes Labor${EN}Secret lab`, "");
	scene10.describe = function () {
		if (MODE.pro) {
			return T`<img src='s10.png'>${DE}Bravo du hast das Spiel geschafft und kannst jetzt eigene Programme schreiben. </br>Hier ist der Quelltext damit Du das Spiel selbst erweitern kannst: ${EN}Bravo, you have completed the game and can now write your own programmes. </br>Here is the source code so that you can extend the game yourself: ${ALL}<a target='_blank' href='https://github.com/kiliansinger/mintrobi/'>https://github.com/kiliansinger/mintrobi/</a> </br>${DE}Nach ${["Süden"]} geht es zur Strandbar.${EN}To the ${["south"]} you can go to the beach bar.` + this.printcommands();
		}
		else return T`<img src='s10.png'>${DE}Schreibe ein Mintrobi-Programm was 2*2*2*3*5*11-1 berechnet. ${EN}Write a Mintrobi program that calculates 2*2*2*3*5*11-1. ${ALL}<a target='_blank' href='https://makecode.microbit.org/#pub:_4VuLC0hXL3Mp'>Code</a>. </br>${DE}Im ${["Norden"]} ist eine Tür mit Zahlenschloss (<em style='color:#0f0;'>${["tippe auf zahlenschloss"]}</em>.) </br>Da muss man sicher die Zahl eingeben, welche du mit dem Gehirn von Mintrobi berechnest! </br>Nach ${["Süden"]} geht es zur Strandbar.${EN}In the ${["north"]} there is a door with a number lock (<em style='color:#0f0;'>${["type on number lock"]}</em>.) </br>There you surely have to enter the number, which you'll calculate with Mintrobi's brain! </br>To the ${["south"]} you can go to the beach bar.` + this.printcommands();
	}
	scene10.south = scene4;
	scene4.northblock = seetang;
	scene4.insert(seetang);
	let numberlockdoor = new Door(T`${DE}Zahlenschloss${EN}number lock`, T`${DE}Ein digitales Eingabefeld an der Tür.${EN}A digital input field on the door.`, { blocking: true, usable: true, speakable: true, locked: true });
	numberlockdoor.use = function () {
		Commands.forward_command = T`${DE}t Zahlenschloss${EN}t number lock`
		return false;
	}
	numberlockdoor.dialog = async function* () {
		const reply = yield T`${DE}Bitte Zahlencode eingeben${EN}Please enter numerical code${ALL}</br><quiet>${["7",""]} ${["8",""]} ${["9",""]}</br>${["4",""]} ${["5",""]} ${["6",""]}</br>${["1",""]} ${["2",""]} ${["3",""]}</br>${["c","",""]} ${["0",""]} ${["ok"," "]}</quiet></p>`;
		if (reply === "1319") {
			numberlockdoor.blocking = false;
			return T`${DE}Die Tür öffnet sich!${EN}The door opens!`
		}
		else return T`${DE}Falscher Code!${EN}Wrong code!`
	}
	scene10.northblock = numberlockdoor;
	scene10.insert(numberlockdoor)
	let scene11 = new Scene(T`${DE}Dunkles Labyrinth${EN}Dark labyrinth`, T`${DE}Es ist stockdunkel hier. Ich glaube ich brauche Mintrobis Hilfe um hier rauszufinden.${EN}It's pitch black in here. I think I need Mintrobi's help to find my way out.`);
	scene11.south = scene10;
	let mintrobi = new Person(T`${DE}Roboter${EN}Robot`, T`${DE}Dein lieber Mintrobi.${EN}Your dear Mintrobi.`);
	scene11.insert(mintrobi);
	mintrobi.dialog = async function* () {
		if (MODE.pro) return T`${DE}Für dieses Spiel musst du einen Mintrobi haben. Du hast jedoch den C++ Programmierkurs gewählt. Weshalb dieses Rätsel übersprungen wird.${EN}For this game you must have a Mintrobi. However, you have chosen the C++ programming course. Therefore, this puzzle is skipped.`;
		if (!("bluetooth" in navigator)) return T`${DE}Du musst einen Chrome/Edge Browser verwenden.${EN}You must use a Chrome/Edge browser.`
		var bluetoothadapter = await navigator.bluetooth.getAvailability()
		let name = "";
		if (bluetoothadapter) {
			name = yield T`${DE}Hallo, endlich können wir miteinander reden. </br>Du musst unbedingt eine Funkverbindung (bluetooth) mit mir aufbauen. </br>Wir wollen meinen Ultraschallsensor testen. Damit ich im dunklen Labyrinth wie eine </br>Fledermaus sehen kann. Damit wir uns immer verbinden können lade bitte das folgende Programm <a target='_blank' href='https://makecode.microbit.org/#pub:_5FkUDgK1tE0k'>Code</a> auf mein Gehirn. </br>Dann drücke auf die Reset Taste auf der Rückseite vom Gehirn und tippe den Text der angezeigt wird hier ein, falls es mehrere von mir hier im Raum gibt. Sonst einfach [ENTER] drücken${EN}Hello, finally we can talk to each other. </br>You absolutely have to establish a radio connection (bluetooth) with me. </br>We want to test my ultrasonic sensor. So that I can see in the dark labyrinth like a </br>bat. So that we can always connect, please load the following programme <a target='_blank' href='https://makecode.microbit.org/#pub:_5FkUDgK1tE0k'>Code</a> onto my brain. </br>Then press the reset button on the back of the brain and type in the text here, if there are more than one of me in the room, otherwise just press [ENTER].`;
		}
		if (bluetoothadapter) await microBitConnect(name);
		let reply2 = yield T`${DE}Schreibe jetzt ein Programm, was den Ultraschallsensor ausliest und den Abstand in cm${EN}Now write a programme that reads the ultrasonic sensor and calculates the distance in cm` + (bluetoothadapter ? T`${ALL}. ` : T`${DE} alle 100ms zurückgibt. </br>${EN} every 100ms. </b>`) + T`${DE}Stecke dann das Gehirn in das Fahrgestell. Achte darauf, dass ich auf dem Boden stehe, wenn mich bewege damit ich nicht vom Tisch falle oder stelle etwas unter mich, während wir programmieren.  Mache die Hand nach vor meinen Ultraschallsensor um die Messungen abzubrechen. Hier ist das Programm was du vervollständigen sollst <a target='_blank' href='https://makecode.microbit.org/#pub:${EN}Then put the brain in the chassis. Make sure I am standing on the floor so I don't fall off the table when I move or put something under me while we program. Put your hand in front of my ultrasonic sensor to stop the measurements. Here is the program I want you to complete <a target='_blank' href='https://makecode.microbit.org/#pub:` + (bluetoothadapter ? "_C5Eb7Lf537CA" : "_J504s0Afb4YH") + "'>Code</a>. " + (bluetoothadapter ? "" : T`${DE}Falls Du per in makecode per usb verbunden bist musst du die Verbindung nach dem hochladen des codes </br>erst noch trennen.${EN}If you are connected by makecode via usb, you must first disconnect the connection after uploading the code.${ALL}<img width='20%' src='unpair.gif'>`) + T`${DE}Wenn Du soweit bist drücke [ENTER]${EN}When you are ready, press [ENTER].`;
		if (bluetoothadapter) await microBitConnect(name);
		try {
			while (true) {
				let val = await Promise.race([
					bluetoothadapter ? microBitReadBluetooth() : readMicrobit(),
					new Promise((_, reject) => setTimeout(reject, 10000, new Error("timeout")))
				]);
				if (val == 0) {
					return T`${DE}Hast du das Gehirn in das Fahrgestell gesteckt?${EN}Did you put the brain in the chassis?`
				}
				let p2 = document.createElement('p');
				p2.innerHTML = val;
				story.appendChild(p2);
				story.scrollTop = story.scrollHeight - story.clientHeight
				if (val < 10.0) break;

				console.log(val);
			}
			while (true) {
				let reply = yield T`${DE}Cool. Der Ultraschallsensor funktioniert. Jetzt kann ich dich aus dem Labyrinth herausführen. </br>Du musst dazu die folgenden Signale empfangen und decodieren: </br>L steht für Links </br>R steht für Rechts </br>Bewege den Motor entsprechend und schreibe Dir die Richtungen auf. Hier ist ein Programm den du Erweitern sollst: ${EN}Cool. The ultrasonic sensor is working. Now I can lead you out of the maze. </br>You have to receive and decode the following signals: </br>L stands for left </br>R stands for right </br>Move the motor accordingly and write down the directions. Here is a program that you should extend: ${ALL}<a target='_blank' href='https://makecode.microbit.org/#pub:` + (bluetoothadapter ? "_RazDmtJYUimp" : "_i6e5XyExURhW") + "'>Code</a> " + T`${DE}Stecke dann das Gehirn in das Fahrgestell. Achte darauf, dass ich auf dem Boden stehe, wenn damit ich nicht vom Tisch falle oder </br>stelle etwas unter mich, während wir programmieren!${EN}Then put the brain into the chassis. Make sure I stand on the floor if so I don't fall off the table or </br>put something under me while we program!${ALL} <p style='color:#0f0;'>${DE}${["1"]} - Los gehts </br>${["2"]} - Ich will den Weg aus dem Labyrinth eingeben. </br>${["3"]} - Ich will später weitermachen.${EN}${["1"]} - Let's go </br>${["2"]} - I want to enter the way out of the labyrinth. </br>${["3"]} - I want to continue later.${ALL}</p>`
				switch (reply) {
					case "1":
						if (bluetoothadapter) {
							await microBitConnect(name);
							await microBitWriteBluetooth("L\n");
							await sleep(2000);
							await microBitWriteBluetooth("R\n");
							await sleep(2000);
							await microBitWriteBluetooth("L\n");
							await sleep(2000);
							await microBitWriteBluetooth("R\n");
							await sleep(2000);
						} else {
							await writeMicrobit("L\n");
							await sleep(2000);
							await writeMicrobit("R\n");
							await sleep(2000);
							await writeMicrobit("L\n");
							await sleep(2000);
							await writeMicrobit("R\n");
							await sleep(2000);
						}
						break;
					case "2":
						let reply5 = yield T`${DE}Wie komme ich aus dem Labyrinth? Bitte gebe den Weg in der Form (LLRR...) ein:${EN}How do I get out of the labyrinth? Please enter the way in the form (LLRR...):`
						if (reply5 == "lrlr") return T`${DE}Gratulation Du hast das Spiel gemeistert! </br>Hier ist der Quelltext damit Du das Spiel selbst erweitern kannst: <a target='_blank' href='https://github.com/kiliansinger/mintrobi/'>https://github.com/kiliansinger/mintrobi/</a> </br>Deiner Fantasie sind keine Grenzen gesetzt. Hier sind tolle <a target='_blank' href='https://joycar.joy-it.net/de/garage/makecode'>Anleitungen</a>. Da kannst du z.B. eine <a target='_blank' href='https://joycar.joy-it.net/de/garage/makecode/13-joy-car-remote-control'>Fernsteuerung</a> bauen. </br>Oder baue eine Sonnenuhr und interessante Elektronikprojekte <a target='_blank' href='https://www.electronic-adventure.com/de/your-journey/part-1'>Abenteuer Elektronik</a>. Alle Bauteile dazu solltest du bereits besitzen.${EN}Congratulations you have mastered the game! </br>Here is the source code so that you can extend the game yourself: <a target='_blank' href='https://github.com/kiliansinger/mintrobi/'>https://github.com/kiliansinger/mintrobi/</a> </br>There are no limits to your imagination. Here are great <a target='_blank' href='https://joycar.joy-it.net/de/garage/makecode'>instructions</a>. For example, you can build a <a target='_blank' href='https://joycar.joy-it.net/de/garage/makecode/13-joy-car-remote-control'>remote control</a>. </br>Or build a sundial and interesting electronics projects <a target='_blank' href='https://www.electronic-adventure.com/de/your-journey/part-1'>Adventure Electronics</a>. You should already have all the components.`;
						else {
							yield T`${DE}Hm leider passt der Weg nicht aber ich habe nochmal an den Anfang des Labyriths zurückgefunden. Bitte [ENTER] drücken.${EN}Unfortunately, the path does not fit but I have found my way back to the beginning of the labyrinth. Please press [ENTER].`
							break;
						}
					case "3":
						return T`${DE}Bis später dann.${EN}See you later.`
					default:
						Commands.understood = false;
						continue;
				}
			}
		} catch {
			return T`${DE}Das hat zulange gedauert. Versuche es einfach nochmal von vorne.${EN}It took too long. Just try it again from the beginning.`
		}
	}
	/**
	 * Prints a string to the canvas at the beginning by adding it to the beginning of Commands.answer.
	 *
	 * @param {string} x - A string param
	 * @return {void}
	 *
	 * @example
	 *
	 *     printfront('hello')
	 */
	function printfront(x) {
		Commands.answer.unshift(x);
	}
	function print(x) {
		Commands.answer.push(x)
	};
	class Commands {
		static recogparam = null;
		static command = "";
		static forward_command = "";
		static helpcnt = 0;
		static helpcntprev = 0;
		static async execute(cmd, isspeechrecog) {//TODO it does not recognize split words like "bottle message"
			cmd = cmd.toString().toLowerCase();
			let delstr;
			if (MODE.lang == DE) delstr = ["=>", "der", "die", "das", "dem", "der", "dem", "den", "die", "das", "ein", "einer", "ein", "einem", "einer", "einem", "einen", "eine", "ein"];
			else if (MODE.lang == EN) delstr = ["=>", "the", "a", "an", "that", "these"];
			let importantprep;
			if (MODE.lang == DE) importantprep = ["an", "mit", "auf", "nach", "durch", "in", "zu"];
			else if (MODE.lang == EN) importantprep = ["to", "with", "towards", "through", "in", "at", "on", "into"];
			let delall = ["!", ".", "?"];
			Commands.answer = [];
			let recog = false;
			for (var del in delall) cmd = cmd.split(delall[del]).join(" ");
			for (var del in delstr) cmd = cmd.split(" " + delstr[del] + " ").join(' ')
			for (var del in importantprep) cmd = cmd.split(" " + importantprep[del] + " ").join(' => ')
			cmd = cmd.replace(/\s+/g, ' ').trim();
			if (cmd === "" && !Commands.lastcommandspeak) return "";
			Commands.command = cmd.toLowerCase();
			console.log(cmd);
			Commands.recogparam = null;
			recog |= Commands.go();
			Commands.recogparam = null;
			recog |= Commands.look();
			Commands.recogparam = null;
			recog |= Commands.use();
			Commands.recogparam = null;
			recog |= Commands.open();
			Commands.recogparam = null;
			recog |= Commands.close();
			Commands.recogparam = null;
			recog |= Commands.take();
			Commands.recogparam = null;
			recog |= Commands.give();
			Commands.recogparam = null;
			recog |= Commands.doapply();
			Commands.recogparam = null;
			recog |= Commands.load();
			Commands.recogparam = null;
			recog |= await Commands.speachrecog();
			Commands.recogparam = null;
			recog |= Commands.save();
			Commands.recogparam = null;
			recog |= Commands.reset();
			Commands.recogparam = null;
			recog |= Commands.de();
			Commands.recogparam = null;
			recog |= Commands.en();
			Commands.recogparam = null;
			recog |= Commands.help();
			Commands.recogparam = null;
			recog |= Commands.look({ at: Commands.command });
			Commands.recogparam = null;
			let commandspeak = await Commands.speak();//needs to be last in line
			recog |= commandspeak;
			Commands.recogparam = null;
			document.getElementById("east").innerText=T`${DE}O${EN}E`.toString();

			if (Commands.forward_command != "") {
				let currentret = Commands.answer.join("");
				var ret = Commands.execute(Commands.forward_command, false)//forwarded commands are never called as isspeechrecog=true
				Commands.forward_command = ""
				return currentret.toString() + await ret;
			} else {

				if (recog) {
					printfront("Ok.\n")
				}
				else {
					if (Commands.lastcommandspeak) commandspeak = await Commands.continuespeak(cmd);
					if (!commandspeak && Commands.answer.length == 0) {
						Commands.lastcommandspeak = commandspeak && !Commands.endofspeak;
						if (isspeechrecog) return "TRYOTHERPOSSIBILITY";
						else {
							print(T`${DE}Was? Tippe <em style='color:#0f0;'>${["hilfe"]}</em>!\n${EN}What? Type <em style='color:#0f0;'>${["help"]}</em>!`)
						}
					}
				}
				Commands.lastcommandspeak = commandspeak && !Commands.endofspeak;
				if (isspeechrecog && commandspeak && !Commands.understood) return "TRYOTHERPOSSIBILITY";
				return Commands.answer.join("");
			}
		}
		static actor = ich;
		static answer = [];
		@when(T`${DE}hilfe${EN}help`)
		@when("h")
		static help() {
			print("Credits: Game engine: K.Singer, story-code: M. Mendoza Delgado, J. Proll, story/graphics: M. Singer, crowdfunding: J. Plate, B. Bauerhenne.\n")
			print(T`<a target='_blank' href='https://classroom.microbit.org/'>${DE}Klassenzimmer für Lehrkräfte${EN}Classroom for teachers${ALL}</a>\n`); 
			print(T`<a target='_blank' href='https://microbit.org/join'>${DE}Klassenzimmer für Schüler:innen${EN}Classroom for students${ALL}</a>\n`); 
			print(T`<a target='_blank' href='https://makecode.com/tutorial-tool'>${DE}Tutorien erstellen${EN}Create tutorials${ALL}</a>\n`);
			print(T`<a target='_blank' href='tutorials${DE}_de.html'>Programmieranleitungen${EN}.html'>Programming tutorials${ALL}</a>\n`);
			print(T`${DE}Befehle${EN}Commands${ALL}:\n`);
			print(T`&#x26AC; ${DE}hilfe${EN}help${ALL}\n`);
			print(T`     ${DE}mit Kurzform${EN}with shortcut${ALL}: h\n`);
			print(T`&#x26AC; ${DE}schaue/betrachte/b (auf,...) (ETWAS)${EN}look/watch/l (at,...) (SOMETHING)\n`);
			print(T`&#x26AC; ${DE}schaue/betrachte/b mich (an)${EN}look/watch/l (at...) me\n`);
			print(T`&#x26AC; ${DE}schaue/betrachte/b (auf,...) rucksack${EN}look/watch/l (at,...) backpack\n`);
			print(T`     ${DE}mit Kurzform: r\n${EN}with shortcut: b\n`);
			print(T`&#x26AC; ${DE}gehe (nach) norden/süden/westen/osten/...\n${EN}go (towards,to) north/south/west/east`);
			print(T`     ${DE}mit Kurzform: n,s,w,o${EN}with shortcut: n,s,w,e${ALL}\n`);
			print(T`&#x26AC; ${DE}verwende/benutze/drücke/ziehe/v ETWAS\n${EN}use/press/pull/u SOMETHING\n`);
			print(T`&#x26AC; ${DE}verwende/benutze/v ETWAS auf/mit/... ETWAS/JEMANDEN\n${EN}use/u SOMETHING with/on SOMETHING/SOMEBODY\n`);
			print(T`&#x26AC; ${DE}öffne/ö ETWAS\n${EN}open/o SOMETHING\n`);
			print(T`&#x26AC; ${DE}schließe/s ETWAS\n${EN}close/c SOMETHING\n`);
			print(T`&#x26AC; ${DE}nimm/m ETWAS\n${EN}take/k SOMETHING\n`);
			print(T`&#x26AC; ${DE}gib/lege/l ETWAS\n${EN}give/drop/put/p SOMETHING\n`);
			print(T`&#x26AC; ${DE}gib/lege/l ETWAS an/zu/... ETWAS/JEMANDEN\n${EN}give/drop/put/p SOMETHING to/at/on/... SOMETHING/SOMEBODY\n`);
			print(T`&#x26AC; ${DE}sprich/rede/tippe/t (mit/in/...) PERSON/COMPUTER\n${EN}speak/talk/type/t (with/into/...) PERSON/COMPUTER\n`);
			print(T`&#x26AC; ${DE}speichere/save SPIELSTANDSNAME\n${EN}save NAMEOFGAMESTATE\n`);
			print(T`&#x26AC; ${DE}lade/load SPIELSTANDSNAME\n${EN}load NAMEOFGAMESTATE\n`);
			print(T`&#x26AC; ${DE}spracherkennung/sp an/aus\n${EN}speechrecognition/sp on/off\n`);
			print("&#x26AC; reset\n");
			print(T`&#x26AC; ${DE}Deutsch/de/Englisch/en${EN}German/de/English/en\n`);
			return true;
		}
		@when("de")
		@when(T`${DE}deutsch${EN}german`)
		static de() {
			console.log("de")
			MODE.lang = DE;
			if (Commands.dospeachrecog) {
				Commands.recognition.stop();
				Commands.dospeachrecog = false;
				Commands.forward_command = T`${DE}sp an${EN}sp on`.toString();
			}
			return true;
		}
		@when("en")
		@when(T`${DE}englisch${EN}english`)
		static en() {
			MODE.lang = EN;
			if (Commands.dospeachrecog) {
				Commands.recognition.stop();
				Commands.dospeachrecog = false;
				Commands.forward_command = T`${DE}sp an${EN}sp on`.toString();
			}
			return true;
		}
		@when(T`${DE}schaue${EN}look`, { at: "scene" })
		@when(T`${DE}betrachte${EN}watch`, { at: "scene" })
		@when(T`${DE}b${EN}l`, { at: "scene" })
		@when(T`${DE}r${EN}b`, { at: T`${DE}rucksack${EN}backpack` })
		@when(T`${DE}schaue${EN}look${ALL} AT`)
		@when(T`${DE}betrachte${EN}watch${ALL} AT`)
		@when(T`${DE}b${EN}l${ALL} AT`)
		@when(T`${DE}schaue${EN}look${ALL} => AT`)
		@when(T`${DE}betrachte${EN}watch${ALL} => AT`)
		@when(T`${DE}b${EN}l${ALL} => AT`)
		static look({ at }) {
			at = at.toString();
			switch (at) {
				case "scene":
					print(Commands.actor.position.describe());
					if (!isEmpty(Commands.actor.position.things) && Commands.actor.position.open) {
						print(T`\n${DE}Desweiteren sieht man:${EN}Furthermore, you can see:`);
						lookrecursive(Commands.actor.position.things, at, true, null, true);
						print("\n");
					}
					return true;
				case T`${DE}mich${EN}me`.toString():
					print(T`${DE}Du bist ${EN}You are ` + Commands.actor.describe());
				//return true;//we du fallthrough on purpuse
				//do not insert anything here
				case T`${DE}rucksack${EN}backpack`.toString():
					if (!isEmpty(Commands.actor.things)) print(T`${DE}In deinem Rucksack befinden sich:${EN}In your backpack you can find:${ALL} \n`);
					else print(T`${DE}Der Rucksack ist leer.${EN}The backpack is empty.`);
					if (Commands.actor.open) for (var i in Commands.actor.things) {
						print(T`${[ Commands.actor.things[i].title[0].toString()]}`.toString());
						print("\n");
					}
					return true;
				default:
					console.log("schaue");
					let found1, found2;
					if (Commands.actor.position.title.toString().toLowerCase() == at) {
						print(Commands.actor.position.describe());
						if (!isEmpty(Commands.actor.position.things) && Commands.actor.position.open) {
							print(T`\n${DE}Desweiteren sieht man:${EN}Furthermore, you can see:`);
							lookrecursive(Commands.actor.position.things, at, true, null, true);
							print("\n");
						}
						return true;
					}
					found1 = lookrecursive(Commands.actor.things, at, false, null, false);
					found2 = lookrecursive(Commands.actor.position.things, at, false, null, false);
					return (found1 !== null) || (found2 !== null);
			}
		}
		@when("w", { direction: "west" })
		@when(T`${DE}westen${EN}west`, { direction: "west" })
		@when(T`${DE}westlich${EN}west`, { direction: "west" })
		@when(T`${DE}gehe westen${EN}go west`, { direction: "west" })
		@when(T`${DE}gehe => westen${EN}go => west`, { direction: "west" })
		@when(T`${DE}o${EN}e`, { direction: "east" })
		@when(T`${DE}osten${EN}east`, { direction: "east" })
		@when(T`${DE}östlich${EN}east`, { direction: "east" })
		@when(T`${DE}gehe osten${EN}go east`, { direction: "east" })
		@when(T`${DE}gehe => osten${EN}go => east`, { direction: "east" })
		@when("s", { direction: "south" })
		@when(T`${DE}süden${EN}south`, { direction: "south" })
		@when(T`${DE}südlich${EN}south`, { direction: "south" })
		@when(T`${DE}gehe süden${EN}go south`, { direction: "south" })
		@when(T`${DE}gehe => süden${EN}go => south`, { direction: "south" })
		@when("n", { direction: "north" })
		@when(T`${DE}norden${EN}north`, { direction: "north" })
		@when(T`${DE}nördlich${EN}north`, { direction: "north" })
		@when(T`${DE}gehe norden${EN}go north`, { direction: "north" })
		@when(T`${DE}gehe => norden${EN}go => north`, { direction: "north" })
		@when(T`${DE}oben${EN}up`, { direction: "up" })
		@when(T`${DE}gehe oben${EN}go up`, { direction: "up" })
		@when(T`${DE}gehe => oben${EN}go => up`, { direction: "up" })
		@when(T`${DE}hoch${EN}up`, { direction: "up" })
		@when(T`${DE}gehe hoch${EN}go up`, { direction: "up" })
		@when(T`${DE}gehe => hoch${EN}go => up`, { direction: "up" })
		@when(T`${DE}unten${EN}down`, { direction: "down" })
		@when(T`${DE}gehe unten${EN}go down`, { direction: "down" })
		@when(T`${DE}gehe => unten${EN}go => down`, { direction: "down" })
		@when(T`${DE}runter${EN}down`, { direction: "down" })
		@when(T`${DE}gehe runter${EN}go down`, { direction: "down" })
		@when(T`${DE}gehe => runter${EN}go => down`, { direction: "down" })
		static go({ direction }) {
			if (Commands.actor.position.hasOwnProperty(direction) || Commands.actor.position[direction]) {
				if (Commands.actor.position[direction + "block"] !== undefined) {
					if (!Commands.actor.position[direction + "block"].blocking) {
						Commands.actor.position = Commands.actor.position[direction];
						Commands.look({ at: "scene" });
						return true;
					}
					else {
						print(T`${DE}Da kann ich nicht hin wegen: ${EN}I cannot go there due to: ` + T`${[ Commands.actor.position[direction + "block"].title[0].toString()]}`.toString()+"!\n")
						return true;
					}
				}
				else {
					Commands.actor.position = Commands.actor.position[direction];
					Commands.look({ at: "scene" });
					return true;
				}
			}
			return false;
		}
		@when(T`${DE}v${EN}u${ALL} ITEM`)
		@when(T`${DE}verwende${EN}use${ALL} ITEM`)
		@when(T`${DE}benutze${EN}press${ALL} ITEM`)
		@when(T`${DE}drücke${EN}push${ALL} ITEM`)
		@when(T`${DE}ziehe${EN}pull${ALL} ITEM`)
		static use({ item }) {
			let { thing } = search(item);
			//if(thing !== null && !Commands.actor.has(thing)){
			//	print(T`<p style='color:#0f0;'>${DE}nehme ${EN}taking `.toString()+thing.title[0].toString()+"</p></br>")
			//	if( thing.takeable && thing.parent != Commands.actor) Commands.actor.take(thing);
			//	else print(T`${DE}geht nicht${EN}does not work${ALL}</br>`)
			//}
			if (thing && thing.usable /*&& Commands.actor.has(thing) */) return thing.use();
			else {
				return false;
			}
		}
		@when(T`${DE}benutze${EN}use${ALL} ITEM => TARGET`)
		@when(T`${DE}verwende${EN}use${ALL} ITEM => TARGET`)
		@when(T`${DE}v${EN}u${ALL} ITEM => TARGET`)
		static doapply({ item, target }) {//we 
			let retval = false;
			let { thing } = search(item);
			let { thing: targetthing } = search(target);
			if (thing && targetthing && !Commands.actor.has(thing)) {
				print(T`<p style='color:#0f0;'>${DE}nehme ${EN}taking `.toString() + thing.title[0].toString() + "</p>")
				if (thing.takeable && thing.parent != Commands.actor) {
					if (Commands.actor.take(thing)) print(T`<p style='color:#0f0;'>${DE}verwende ${EN}use `.toString() + thing.title[0].toString() + T`${DE} mit ${EN} with ` + targetthing.title[0].toString() + "</p>")
				}
				else print(T`${DE}geht nicht${EN}does not work${ALL}</br>`)
			}

			if (thing && targetthing && thing.applicable && Commands.actor.has(thing)) {
				if (thing.applytarget.hasOwnProperty(targetthing.name))
					retval = thing.doapply(targetthing);
			}
			if (retval) return retval;
			else {
				let { thing } = search(target);
				let { thing: targetthing } = search(item);
				if (thing && targetthing && !Commands.actor.has(thing)) {
					print(T`<p style='color:#0f0;'>${DE}nehme ${EN}taking `.toString() + thing.title[0].toString() + "</p>")
					if (thing.takeable && thing.parent != Commands.actor) {
						if (Commands.actor.take(thing)) print(T`<p style='color:#0f0;'>${DE}verwende ${EN}use `.toString() + thing.title[0].toString() + T`${DE} mit ${EN} with ` + targetthing.title[0].toString() + "</p>")
					}
					else print(T`${DE}geht nicht${EN}does not work${ALL}</br>`)
				}
				if (thing !== null && targetthing !== null && thing.applicable && Commands.actor.has(thing)) {
					if (thing.applytarget.hasOwnProperty(targetthing.name))
						return thing.doapply(targetthing);
				}
				return false;
			}

		}
		static openbool(item, state) {
			let { thing } = search(item);
			if (thing !== null) {
				if (thing.blockable) {
					if (thing.locked) {
						print(T`${DE}Das geht nicht.${EN}That's not possible.`);
						return true;
					}
					else {
						thing.blocking = !state;
						Commands.look({ at: item });
						return true;
					}
				}
				else if ((state == true && thing.openable) || (state == false && thing.closable)) {
					thing.open = state;
					//iterate over all stuff and take it if takeable.
					Commands.look({ at: item });
					return true;
				}
				return false;
			}
			return false;
		}
		@when(T`${DE}öffne${EN}open${ALL} ITEM`)
		@when(T`${DE}ö${EN}o${ALL} ITEM`)
		static open({ item }) {
			return Commands.openbool(item, true);
		}
		@when(T`${DE}schließe${EN}close${ALL} ITEM`)
		@when(T`${DE}s${EN}c${ALL} ITEM`)
		static close({ item }) {
			return Commands.openbool(item, false);
		}
		@when(T`${DE}nimm${EN}take${ALL} ITEM`)
		@when(T`${DE}m${EN}k${ALL} ITEM`)
		static take({ item }) {
			let { mine, thing } = search(item);
			if (thing !== null && thing.takeable && thing.parent != Commands.actor) {
				return Commands.actor.take(thing);
			}
			else {
				return false;
			}
		}
		@when(T`${DE}gib${EN}give${ALL} ITEM => TARGET`)
		@when(T`${DE}gebe${EN}give${ALL} ITEM => TARGET`)
		@when(T`${DE}lege${EN}put${ALL} ITEM => TARGET`)
		@when(T`${DE}lege${EN}drop${ALL} ITEM => TARGET`)
		@when(T`${DE}l${EN}p${ALL} ITEM => TARGET`)
		@when(T`${DE}gib${EN}give${ALL} ITEM`, { target: "scene" })
		@when(T`${DE}gebe${EN}give${ALL} ITEM`, { target: "scene" })
		@when(T`${DE}lege${EN}put${ALL} ITEM`, { target: "scene" })
		@when(T`${DE}lege${EN}drop${ALL} ITEM`, { target: "scene" })
		@when(T`${DE}l${EN}p${ALL} ITEM`, { target: "scene" })
		static give({ item, target }) {//todo all logic should be in Thing class
			let { mine, thing } = search(item);
			if (mine) {
				let targetthing;
				if (target === "scene") {
					if (!thing.dropable) {
						return false;
					}
					targetthing = Commands.actor.position;
				}
				else ({ thing: targetthing } = search(target));
				if (thing !== null && targetthing !== null && (targetthing.open || targetthing.receiving) && mine) {
					return targetthing.take(thing);
				}
				return false;
			} else {
				return false;
			}
		}
		static lastperson;
		static lastcommandspeak = false;
		static async continuespeak(text2) {
			return Commands.speak({ person: Commands.lastperson, text: text2 });
		}
		static endofspeak = false;
		//do not use empty language cases
		@when(T`${DE}sprich${EN}speak${ALL} => PERSON`, { text: "" })
		@when(T`${DE}sprich${EN}speak${ALL} PERSON`, { text: "" })
		@when(T`${DE}spreche${EN}speak${ALL} => PERSON`, { text: "" })
		@when(T`${DE}spreche${EN}speak${ALL} PERSON`, { text: "" })
		@when(T`${DE}rede${EN}talk${ALL} => PERSON`, { text: "" })
		@when(T`${DE}rede${EN}talk${ALL} PERSON`, { text: "" })
		@when(T`${DE}tippe${EN}type${ALL} => PERSON`, { text: "" })
		@when(T`${DE}tippe${EN}type${ALL} PERSON`, { text: "" })
		@when("t => PERSON", { text: "" })
		@when("t PERSON", { text: "" })
		static async speak({ person, text }) {
			console.log(JSON.stringify(person))
			let { thing: personobj } = search(person, Person);
			if (personobj !== null && personobj.speakable) {
				Commands.understood = true;
				Commands.lastperson = person;
				let ret = await personobj.speak(text);
				print((!Commands.understood ? T`${DE}Was? ${EN}What? ` : "") + ret.value);
				Commands.endofspeak = ret.done;
				return true;
			}
			//else print(T`${DE}Geht so nicht.${EN}It doesn't work like that.`);
			return false;
		}
		static dospeachrecog = false;
		static recognition = null;
		static synthesis = null;
		static averagespeakvol = 0;
		@when(T`${DE}spracherkennung${EN}speachrecognition${ALL} ONOFF`)
		@when("sp ONOFF")
		static async speachrecog({ onoff }) {
			if (onoff.toLowerCase() == T`${DE}an${EN}on`) {
				if (Commands.dospeachrecog) return true
				Commands.dospeachrecog = true;
				let stream = null;
				let audioContext = null;
				let mediaStreamAudioSourceNode = null;
				let analyserNode = null;
				let pcmData = null;
				if (! /Android/i.test(navigator.userAgent)) {//In android the simultaneous Audiomonitoring does not work
					stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
					audioContext = new AudioContext();
					mediaStreamAudioSourceNode = audioContext.createMediaStreamSource(stream);
					analyserNode = audioContext.createAnalyser();
					analyserNode.fftSize = 1024;
					mediaStreamAudioSourceNode.connect(analyserNode);

					pcmData = new Float32Array(analyserNode.fftSize);
				}
				const checkVolume = () => {
					if (/Android/i.test(navigator.userAgent)) return 0.00001;//In android the simultaneous Audiomonitoring does not work
					analyserNode.getFloatTimeDomainData(pcmData);
					let sumSquares = 0.0;
					for (const amplitude of pcmData) { sumSquares += amplitude * amplitude; }
					return Math.sqrt(sumSquares / pcmData.length);
				}

				window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
				// setup SpeechRecognation
				if (Commands.recognition) Commands.recognition.lang = (MODE.lang == EN ? 'en-US' : 'de-DE');
				else {
					Commands.recognition = new SpeechRecognition();
					Commands.recognition.continous = true;
					Commands.recognition.interimResults = true;
					Commands.recognition.lang = (MODE.lang == EN ? 'en-US' : 'de-DE');
					Commands.recognition.maxAlternatives = 20;

					//https://www.w3.org/TR/jsgf/
					//const grammar = '#JSGF V1.0; grammar colors; public <color> = aqua | azure | beige | bisque | black | blue | brown | chocolate | coral | crimson | cyan | fuchsia | ghostwhite | gold | goldenrod | gray | green | indigo | ivory | khaki | lavender | lime | linen | magenta | maroon | moccasin | navy | olive | orange | orchid | peru | pink | plum | purple | red | salmon | sienna | silver | snow | tan | teal | thistle | tomato | turquoise | violet | white | yellow ;'
					//window.SpeechGrammarList = window.SpeechGrammarList || window.webkitSpeechGrammarList;
					//const speechRecognitionList = new SpeechGrammarList();
					//speechRecognitionList.addFromString(grammar, 1);
					//Commands.recognition.grammars = speechRecognitionList;


					//
					// waiting for speech results
					Commands.recognition.addEventListener('result', async (event) => {
						const transcript = event.results[0][0].transcript;
						console.log(transcript)
						// check if the voice input has ended
						if (event.results[0].isFinal) {
							Commands.averagespeakvol = checkVolume();
							let answer = "";
							let found = false;
							let cmd = "";
							for (let a = 0; a < event.results[0].length; ++a) {
								cmd = event.results[0][a].transcript;
								let intermediateanswer = await Commands.execute(cmd, true);
								if (intermediateanswer != "TRYOTHERPOSSIBILITY") {
									answer = intermediateanswer;
									found = true;
									break;
								}
								console.log("!!!!!" + a + event.results[0][a].transcript)
							}
							if (!found) {
								cmd = event.results[0][0].transcript
									.replaceAll(T`${DE}eins${EN}one`, "1")
									.replaceAll(T`${DE}zwei${EN}two`, "2")
									.replaceAll(T`${DE}drei${EN}three`, "3")
									.replaceAll(T`${DE}vier${EN}four`, "4")
									.replaceAll(T`${DE}fünf${EN}five`, "5")
									.replaceAll(T`${DE}sechs${EN}six`, "6")
									.replaceAll(T`${DE}sieben${EN}seven`, "7")
									.replaceAll(T`${DE}acht${EN}eight`, "8")
									.replaceAll(T`${DE}neuen${EN}nine`, "9")
									.replaceAll(T`${DE}zehn${EN}ten`, "10")
									.replaceAll(T`${DE}ein${EN}one`, "1")
								answer = await Commands.execute(cmd, true)
								if (answer == "TRYOTHERPOSSIBILITY") {
									cmd = event.results[0][0].transcript
									answer = await Commands.execute(cmd, false)
								}
							}
							updateConsole(cmd, answer);
							Commands.dospeachrecog = false;
							Commands.recognition.abort();
							Commands.synthesis = new SpeechSynthesisUtterance();
							Commands.synthesis.text = answer.toString().replace(/<quiet>(.*?)<\/quiet>/ig, '').replace(/(<([^>]+)>)/ig, '').replaceAll("&#x26AC;", "-")
							Commands.synthesis.lang = (MODE.lang == EN ? 'en-US' : 'de-DE');
							Commands.synthesis.volume = 1; // 0 to 1
							Commands.synthesis.rate = 1; // 0.1 to 10
							Commands.synthesis.pitch = 1; //0 to 2
							window.speechSynthesis.speak(Commands.synthesis);
							Commands.synthesis.onend = function (e) {
								Commands.dospeachrecog = true;
								Commands.synthesis.onboundary = null
								Commands.recognition.start();//function(e) {
							}
							Commands.synthesis.onboundary = function (e) {
								//if(![','].includes(e.utterance.text.charAt(e.charIndex-2)))
								//	if(e.name!="sentence") return
								if (e.name != "sentence") return
								//console.log(e.name)


								let vol = checkVolume()

								//Commands.averagespeakvol=Commands.averagespeakvol*0.95+0.05*vol;


								console.log(vol + " " + Commands.averagespeakvol)
								if (vol > 10 * Commands.averagespeakvol) {
									if (window.speechSynthesis){
										window.speechSynthesis.cancel();
										if(Commands.synthesis) Commands.synthesis.onboundary = null
										if(Commands.recognition) {
											try{
												Commands.recognition.start();//function(e) {
											}catch (e){
												
											}
										}
									}
								} else Commands.averagespeakvol = Commands.averagespeakvol * 0.5 + 0.5 * vol;


							}

						}
					});
					Commands.recognition.addEventListener('end', () => {
						if (Commands.dospeachrecog) Commands.recognition.start()
					});
				}
				if (Commands.recognition) try { Commands.recognition.start(); } catch (e) { }
				print(T`${DE}Spracherkennung aktiviert! Du kannst immer zwischen den Sätzen laut "Stop!" sagen. Anstatt ENTER drücken kannst du immer enter sagen.${EN}Speech recognition activated! In between the sentences you can always say loud "Stop!". Instead of pressing ENTER, you can always say enter.`)
				return true;
			}
			else {
				Commands.dospeachrecog = false;
				if (Commands.recognition) try { Commands.recognition.abort(); } catch (e) { }
				print(T`${DE}Spracherkennung deaktiviert!${EN}Speech recognition deactivated!`)
				return true;
			}
		}
		@when("speichere TITEL")
		@when("save TITEL")
		static save({ title }) {
			let dump2 = Obj.dump();
			localStorage.setItem(title, dump2);
			return true;
		}
		@when("lade TITEL")
		@when("load TITEL")
		static load({ title }) {
			let dump2 = localStorage.getItem(title)
			if (dump2 !== null) {
				Obj.restore(dump2);
				return true;
			} else return false;
		}
		@when("reset")
		static reset() {
			return Commands.load({ title: "reset" });
		}
		static intro() {
			let dump = Obj.dump();
			localStorage.setItem("reset", dump);
			let dump2 = localStorage.getItem("current")
			if (dump2 !== null) {
				Obj.restore(dump2);
			}
			Commands.answer = [];
			Commands.look({ at: T`${DE}mich${EN}me`.toString() });
			print(T`${DE}Du trägst einen ${["Rucksack"]}.${EN}You are carrying a ${["backpack"]}.`);
			print("\n");
			Commands.look({ at: "scene" });
			if (Commands.actor.position == omazuhause) {
				print(T`${DE}Gebe z.B. ein: <em style='color:#0f0;'>${["rede mit oma"]}</em> oder <em style='color:#0f0;'>${["w"]}</em>${EN}Enter for example: <em style='color:#0f0;'>${["speak to granny"]}</em> or <em style='color:#0f0;'>${["w"]}</em>`);
			}
			return Commands.answer.join("");
		}
	}
</script>

<!-- Input handler -->
<script type="text/babel" data-presets="env-plus">
	let lastinput = "";
	let story = document.getElementById('story')
	let inp = document.getElementById('inp')
	let prompt = document.getElementById('prompt')
	async function exec(el,prepend=false) {
		let txt;
		if(typeof el == "string") txt=el;
		else txt=el.innerHTML;
		console.log(txt)
		let command;
		if(!prepend){ 
			command = document.getElementById("inp").value + " " + txt;
			let answer = await Commands.execute(command, false);
			updateConsole(command, answer,false);
		}else{
			let old=document.getElementById("inp").value;
			command = txt;
			let answer = await Commands.execute(command, false);
			updateConsole(command, answer,false);
			document.getElementById("inp").value=old
		}

	}
	function typeCommand(el) {
		let txt;
		if(typeof el == "string") txt=el;
		else txt=el.innerHTML;
		document.getElementById("inp").value+= txt;
		document.getElementById("inp").disabled = false
		//document.getElementById("inp").focus();
	}
	function clearCommand() {
		document.getElementById("inp").value="";
		document.getElementById("inp").disabled = false
		//document.getElementById("inp").focus();
	}
	async function updateConsole(cmd, answer,focus=true) {
		lastinput = cmd;
		let p = document.createElement('p');
		p.innerHTML = cmd;
		p.className = 'command';
		story.appendChild(p);
		let p2 = document.createElement('p');
		p2.innerHTML = answer;
		story.appendChild(p2);
		inp.value = '';
		story.scrollTop = story.scrollHeight;//- story.offsetHeight;

		setTimeout(function () { story.scrollTop = story.scrollHeight - story.clientHeight }, 100);
		let dump = Obj.dump();
		localStorage.setItem("current", dump);
		document.getElementById("inp").disabled = false
		if(focus)document.getElementById("inp").focus();
	}
	async function start() {
		try {
			let answer = Commands.intro();
			let p2 = document.createElement('p');
			p2.innerHTML = answer;

			story.appendChild(p2);
			inp.value = '';
			setTimeout(function () { story.scrollTop = story.scrollHeight - story.clientHeight }, 3000);
			document.getElementById("inp").addEventListener("keydown", async (e) => {
				if (event.keyCode == 13) {
					if (window.speechSynthesis) {
						window.speechSynthesis.cancel();
						//Commands.dospeachrecog = true;
						if(Commands.synthesis) Commands.synthesis.onboundary = null
						if(Commands.recognition) {
							try{
								Commands.recognition.start();//function(e) {
							}catch (e){
								
							}
						}
					}
					document.getElementById("inp").disabled = true;

					let cmd = inp.value;
					let answer = await Commands.execute(cmd, false);

					updateConsole(cmd, answer);


				}
				else if (event.keyCode == 38) {//up arrow
					document.getElementById("inp").focus();
					document.getElementById("inp").value = lastinput;
				}
			}, false);
		} catch (e) {
			console.log(e)
			localStorage.clear()
			//setTimeout(() => window.location.reload(), 3000);
		}
	}
</script>

</html>